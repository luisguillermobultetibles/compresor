<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<textarea id="textarea1"></textarea>
<script>

  // Factorización "hacker" de números naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el Domingo 22 de octubre de 2023; 11:20 AM
  // (pendiente de depuración y corrección de errores sintácticos)
  // Todos los derechos reservados, por favor contáctenos personalmente para cualquier uso comercial.
  // Uso académico autorizado.
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  // For example, try to factorize: RSA-2048
  textArea1.value = '1230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413';

  function leerAreaDeTexto() {
    return textArea1.value;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.value = String(s);
  }

  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarMenorFactorPrimo(decimal) {
    decimal = String(decimal);
    let valorEnteroGrande = BigInt(decimal);

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos de las dos cadenas coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (valorEnteroGrande < 1n) {
      return resultado; // devolver la entrada, pasa menor que dos y hasta tres, pero déjalo así para legibilidad
    }

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => {
          return element[0] === par[0] && element[1] === par[1];
        },
      );
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos
    function agregarCandidatosDeFactores(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      // si no existe el par en la lista agrégalo
      if (!existsCandidates(par)) {
        candidatos.push(par);
      }
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(1, decimal);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores('1', '1');
        agregarCandidatosDeFactores('3', '7');
        agregarCandidatosDeFactores('9', '9');
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores('1', '3');
        agregarCandidatosDeFactores('7', '9');
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores('1', '7');
        agregarCandidatosDeFactores('3', '9');
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores('1', '9');
        agregarCandidatosDeFactores('3', '3');
        agregarCandidatosDeFactores('7', '7');
        break;
      }
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    // Longitud estimada de la raíz cuadrada
    let longitudRaiz = Math.round(decimal.length / 2);

    // Después de 200 iteraciones se eliminan los candidatos de menos dos dígitos,
    // de 300 las de menos de tres, así sucesivamente;
    let iteraciones = 0;

    if (candidatos.length > 0) {
      do {

        console.log(JSON.stringify(candidatos));

        // Se toma en primer par
        let parEnAnalisis = [String(candidatos[0][0]), String(candidatos[0][1])];
        candidatos.shift();

        iteraciones++;
        candidatos = candidatos.filter(elementos => {
          return elementos[0].length > Math.trunc(iteraciones / 100) && elementos[1].length < Math.trunc(iteraciones / 100);
        });

        // Se toma el índice del candidato más corto del par (como cadenas para incluir los ceros)
        let via = parEnAnalisis[0] < parEnAnalisis[1] ? 0 : 1;

        // Se convierten las propuestas a enteros grandes, para eliminar ceros a la izquierda
        let propuesta1 = BigInt(parEnAnalisis[via]);
        let propuesta2 = BigInt(parEnAnalisis[1 - via]);

        // Se desecha la propuesta si el tamaño excede la longitud de la raíz cuadrada
        if (parEnAnalisis[via].length > longitudRaiz || parEnAnalisis[1 - via].length > longitudRaiz) {
          continue;
        }

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (propuesta1 !== 1n && valorEnteroGrande % propuesta1 === 0n) {
          return propuesta1.toString();
        } else if (propuesta2 !== 1n && valorEnteroGrande % propuesta2 === 0n) {
          return propuesta2.toString();
        }

        // agregar todos los candidatos formados por los 10 dígitos a la izquierda incluido el cero
        for (let digito = 0; digito < 10; digito++) {
          // Se agregan ceros a la izquierda
          // Siempre que los últimos dígitos del producto coincidan
          let producto = BigInt(propuesta1 * propuesta2);
          if (producto < valorEnteroGrande && coincidenciasAlFinal(decimal, producto.toString()) >= (producto.toString().length - 2)) {
            // Con al menos dos dígitos de error para el acarreo y se concatenan con su formato actual
            agregarCandidatosDeFactores(String(digito) + parEnAnalisis[via], parEnAnalisis[1 - via]);
            agregarCandidatosDeFactores(parEnAnalisis[via], String(digito) + parEnAnalisis[1 - via]);
          } else if (producto === valorEnteroGrande) {
            return propuesta1 < propuesta2 ? String(propuesta1) : String(propuesta2);
          }
        }
      } while (candidatos.length > 0);
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  // Armar una salida elegante (por el momento pasajera), para la factorización del número.
  function factorizacion(x) {
    let resultado;
    let cocienteResidual = BigInt(String(x).trim());
    if (cocienteResidual === 0n || cocienteResidual === 1n) {
      resultado = cocienteResidual.toString();
    } else {
      resultado = '1';
      let menorFactorPrimo;
      do {
        menorFactorPrimo = encontrarMenorFactorPrimo(cocienteResidual);
        if (BigInt(menorFactorPrimo) >= 2n) {
          resultado += ' x ' + menorFactorPrimo.toString();
          cocienteResidual = cocienteResidual / BigInt(menorFactorPrimo);
        }
      } while (BigInt(menorFactorPrimo) >= 2n);
    }
    return resultado;
  }


</script>
<button onclick="imprimirAreaDeTexto(leerAreaDeTexto() + ' = ' + factorizacion(leerAreaDeTexto()));">
    Factorizar
</button>
</body>
</html>