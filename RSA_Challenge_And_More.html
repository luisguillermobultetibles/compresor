<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<textarea id="textarea1"></textarea>
<script>

  // Factorización "hacker" de números naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el lunes 23 de octubre de 2023; 11:20 AM
  // En fase de depuración y puesta a punto.
  // Todos los derechos reservados, por favor contáctenos personalmente para cualquier uso comercial.
  // Uso académico autorizado.
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  // For example, try to factor the old RSA-250
  textArea1.value = '2140324650240744961264423072839333563008614715144755017797754920881418023447140136643345519095804679610992851872470914587687396261921557363047454770520805119056493106687691590019759405693457452230589325976697471681738069364894699871578494975937497937';

  // Must return RSA-250 factor: '64135289477071580278790190170577389084825014742943447208116859632024532344630238623598752668347708737661925585694639798853367',
  //                         and '3337202759497815655622601060535511422794076034476755466678452098702384172921'.
  //
  // this values was factored in February 2020 by Fabrice Boudot, Pierrick Gaudry,
  // Aurore Guillevic, Nadia Heninger, Emmanuel Thomé, and Paul Zimmermann. The announcement of the factorization occurred on February 28.
  // The factorisation of RSA-250 utilised approximately 2700 CPU core-years, using a 2.1 GHz Intel Xeon Gold 6130 CPU as a reference.
  // The computation was performed with the Number Field Sieve algorithm, using the open source CADO-NFS software.
  // The team dedicated the computation to Peter Montgomery, an American mathematician known for his contributions to computational
  // number theory and cryptography who died on February 18, 2020 and had contributed to factoring RSA-768.
  // https://web.archive.org/web/20200228234716/https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2020-February/001166.html
  // "[Cado-NFS-discuss] Factorization of RSA-250". Archived from the original on 2020-02-28. Retrieved 2020-02-28.
  //
  // Según:
  // fhttps://es.wikipedia.org/wiki/N%C3%BAmeros_RSA
  //
  // then try to solve ($200 000.00 premium) RSA-2048 = '25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357'

  function leerAreaDeTexto() {
    return textArea1.value;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.value = String(s);
  }

  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarMenorFactorPrimo(decimal) {
    decimal = String(decimal);
    let valorEnteroGrande = BigInt(decimal);

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos de las dos cadenas coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (valorEnteroGrande < 1n) {
      return resultado; // devolver la entrada, pasa menor que dos y hasta tres, pero déjalo así para legibilidad
    }

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => {
          return element[0] === par[0] && element[1] === par[1];
        },
      );
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos
    function agregarCandidatosDeFactores(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      // si no existe el par en la lista agrégalo
      if (!existsCandidates(par)) {
        candidatos.push(par);
      }
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(1, decimal);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores('1', '1');
        agregarCandidatosDeFactores('3', '7');
        agregarCandidatosDeFactores('9', '9');
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores('1', '3');
        agregarCandidatosDeFactores('7', '9');
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores('1', '7');
        agregarCandidatosDeFactores('3', '9');
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores('1', '9');
        agregarCandidatosDeFactores('3', '3');
        agregarCandidatosDeFactores('7', '7');
        break;
      }
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    // Longitud estimada de la raíz cuadrada
    let longitudRaiz = Math.round(decimal.length / 2);

    // Después de 200 iteraciones se eliminan los candidatos de menos dos dígitos,
    // de 300 las de menos de tres, así sucesivamente;
    let iteraciones = 0;

    if (candidatos.length > 0) {
      do {

        console.log(JSON.stringify(candidatos));

        // Se toma en primer par
        let parEnAnalisis = [String(candidatos[0][0]), String(candidatos[0][1])];
        candidatos.shift();

        iteraciones++;
        candidatos = candidatos.filter(elementos => {
          return elementos[0].length > Math.trunc(iteraciones / 100) && elementos[1].length > Math.trunc(iteraciones / 100);
        });

        // Se toma el índice del candidato más corto del par (como cadenas para incluir los ceros)
        let via = parEnAnalisis[0] < parEnAnalisis[1] ? 0 : 1;

        // Se convierten las propuestas a enteros grandes, para eliminar ceros a la izquierda
        let propuesta1 = BigInt(parEnAnalisis[via]);
        let propuesta2 = BigInt(parEnAnalisis[1 - via]);

        // Se desecha la propuesta si el tamaño excede la longitud de la raíz cuadrada
        if (parEnAnalisis[via].length > longitudRaiz || parEnAnalisis[1 - via].length > longitudRaiz) {
          continue;
        }

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (propuesta1 !== 1n && valorEnteroGrande % propuesta1 === 0n) {
          return propuesta1.toString();
        } else if (propuesta2 !== 1n && valorEnteroGrande % propuesta2 === 0n) {
          return propuesta2.toString();
        }

        // agregar todos los candidatos formados por los 10 dígitos a la izquierda incluido el cero
        for (let digito = 0; digito < 10; digito++) {
          // Se agregan ceros a la izquierda
          // Siempre que los últimos dígitos del producto coincidan
          let producto = BigInt(propuesta1 * propuesta2);
          if (producto < valorEnteroGrande && coincidenciasAlFinal(decimal, producto.toString()) >= (producto.toString().length - 3)) {
            // Con al menos dos dígitos de error para el acarreo y se concatenan con su formato actual
            agregarCandidatosDeFactores(String(digito) + parEnAnalisis[via], parEnAnalisis[1 - via]);
            //agregarCandidatosDeFactores(parEnAnalisis[via], String(digito) + parEnAnalisis[1 - via]);
          } else if (producto === valorEnteroGrande) {
            return propuesta1 < propuesta2 ? String(propuesta1) : String(propuesta2);
          }
        }
      } while (candidatos.length > 0);
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  // Armar una salida elegante (por el momento pasajera), para la factorización del número.
  function factorizacion(x) {
    let resultado;
    let cocienteResidual = BigInt(String(x).trim());
    if (cocienteResidual === 0n || cocienteResidual === 1n) {
      resultado = cocienteResidual.toString();
    } else {
      resultado = '1';
      let menorFactorPrimo;
      do {
        menorFactorPrimo = encontrarMenorFactorPrimo(cocienteResidual);
        if (BigInt(menorFactorPrimo) >= 2n) {
          resultado += ' x ' + menorFactorPrimo.toString();
          cocienteResidual = cocienteResidual / BigInt(menorFactorPrimo);
        }
      } while (BigInt(menorFactorPrimo) >= 2n);
    }
    return resultado;
  }


</script>
<button onclick="imprimirAreaDeTexto(leerAreaDeTexto() + ' = ' + factorizacion(leerAreaDeTexto()));">
    Factorizar
</button>
</body>
</html>