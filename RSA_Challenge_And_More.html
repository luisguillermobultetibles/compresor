<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<p>Página de prueba de algoritmos y técnicas de súper computación en html.</p>
<p>Lic. Luis Guillermo Bultet Ibles. 2023. Cuba.</p>
<br>
<textarea id="textarea1"></textarea>
<br>
<input id="infija" type="checkbox" checked="false"><label> Habilitar compresión recursiva vs teorema general de la
    aritmética</label>
<br>
<input id="compresionCheckButton" type="checkbox"><label> Habilitar notación infija vs notación html</label>
<p id="salida"></p>
<script>

  document.title = 'Factorización de números grandes (Capítulo I: Ruptura de los retos de RSA en 1 hora).';

  // Factorización "hacker" de números naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el lunes 30 de octubre de 2023; 01:56 PM
  // No critique, sabemos que podemos optimizar y que puede hacerlo mejor, nosotros también
  // no tenemos tiempo para demostrárselo, estamos en fase de pruebas, todavía no llegamos
  // a la fase optimización, depuración y puesta a punto.
  //
  // Todos los derechos reservados, por favor contáctenos personalmente para cualquier uso comercial.
  // Uso académico autorizado.
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  // Try to solve ($200 000.00 premium retirado) RSA-2048
  const RSA_2048 = 25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357n;
  // textArea1.value = '25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357';
  // De verdad que no es primo, no pasa la prueba china.

  /*

    599823897
    419433555789
527783033874687778946687


  */

  // By the way, begin with this (should return: 465675465116607065549 x 4892055594575155744537):
  // textArea1.value = '3405216300313504830198257210261655966267675384939576673511952248673362411735468038563372942490642693347467098478001335308975250937544195016567619003881616581236469669041265048258537672640665463788514955970507947571047389698184377657355682259659379177022817188359345341243392636514070566217447251850070571480516170787647344639275129176217682619396957509988852559050815094899119273811632676055806597283353578559544597435660107932846181164403554578224521980922371344982004954744947671889457981629190043745603074129550595705148033748074400384250426619344631335191298245210926069812566566078649792586377987899724032939882251114016759873436781730775872542761850297205528168913014427877873693607685642431568955810061806772536785342169354600440970717468879613846425783841452360706615751771436613387820470838114784129829717383821672031891046689524997794852111471334550655423073873902897251302655117188251656610234291491121248240445081547918201170467611571581199482079106671527752098222693031868837060919791708943843768404406641474438580353806106943164418846416040298959554375337500566517394988430088924858580286243780477533876990046865285269715830068376198629862066631612350161944705322118895058583325087799628008808757794447247498260598375534330784129642281105429434347039219480683114237584581062123260604906453400842321463528782535007336953624603886315153245660419983454159353103323610612128888908318885568953086702334710765132039444847804378993419090689588822190144011845538362910077658158256855911539393534628195788126975642820671960038795741353486714292916964865346559596343384934418598281828211087048647383152955212351160688553820034390970520856885389504165919483513569420468207229867701986649862393859388750045503679635721779745999222652606322073667021790621567793599232889209408029326738917935160031194914540406992255116936118231078175916351157401421435037499779581862250394497294989138937944589115746637271086620986632999375685686929871241269657292057866993269718024018605211282433932998120138618871336205487369389749750897797941916787686017331310432382424295397394153331276861585409642431629370511619447925821370535265524073475329696472450322247741571029969995399092938132933711822375255950130804347686175249093717361152945717053657562150905550020512570966820321634995846441592759666700760332803799057476197075324637846791910834886939833786920375073590631543298568386777276782059915197303739269504961472133198505216128927411639946173171031086206969666767188157407328113307292411113483557089761354000418219248540894532719593418891885158661824404980944671270792818634618307550163011068483795833207548971795420532375551746155787548389505644576382098191583994012712098100936134091612769904478085504917446181533641424671007431736078792438157458867415502746566404460014256342218770971917689729350131580995770805558163537058667726710607209817923972296769838794779434114207745612548504801013253090838553166897658335659269013901857653916714799350902647181525613449719142054491291860418552161636012799087121472707339771648116201827523936452308382402110572859195250161756388332200839820703404793048612071811468209146151295713744586974897766393037057567381925992618644101365267839319958370726251558455850346650100837249835931123223590830099522596001037236079389134875880994561034518704266768152248684173598604104437629250854300853039039395609075709872102487790618816944354652065385380410589277744293212890625000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
  textArea1.value = '12345';

  function leerAreaDeTexto() {
    return textArea1.value;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.value = String(s);
  }

  // Funciones matemáticas comunes

  // Raiz cuadrada
  // from https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
  function sqrt(value) {
    if (value < 0n) {
      throw 'square root of negative numbers is not supported';
    }

    if (value < 2n) {
      return value;
    }

    function newtonIteration(n, x0) {
      const x1 = ((n / x0) + x0) >> 1n;
      if (x0 === x1 || x0 === (x1 - 1n)) {
        return x0;
      }
      return newtonIteration(n, x1);
    }

    return newtonIteration(value, 1n);
  }

  // power, solo enteros grandes
  function pow(base, exponent) {
    let result;
    if (base === 0n) {
      return 0n;
    } else if (base === 1n) {
      result = 1n;
    } else if (exponent === 2n) {
      result = base * base;
    } else if (exponent === 1n) {
      result = base;
    } else if (exponent === 0n) {
      result = 1n;
    } else if (exponent % 2n === 0n) {
      result = pow(pow(base, exponent / 2n), 2n);
    } else { // Legendre algorithm
      result = base * pow(base, exponent - 1n);
    }
    return result;
  }

  // Raíz enésima
  // from https://stackoverflow.com/questions/64190185/how-do-i-extract-the-nth-root-of-a-bigint-in-javascript
  function root(n, base) {
    // if (n % 2n === 0) return sqrt(root(n / 2, base)); // se degrada la precision en enteros
    let result = base + 1n;
    const k1 = n - 1n;
    let u = base;
    while (u < result) {
      result = u;
      u = ((u * k1) + base / pow(u, k1)) / n;
    }
    return result;
  }

  // Resto de la division base^exp mod m
  function modpow(base, exp, m) {
    let result = 1n;
    while (exp > 0n) {
      if ((exp & 1n) === 1n) {
        result = (result * base) % m;
      }
      exp = exp >> 1n;
      base = (base * base) % m;
    }
    return result;
  }

  function fastModpow(base, exp, m) {
    if (m === 1n) return 0n;
    if (exp === 0n) return 1n % m;
    if (base === 0n) return 0n;
    if ((exp === 1n) && (m !== 0n)) return base % m;
    if (base * exp < 100n) { // fast
      return pow(base, exp) % m;
    } else {
      let there = primes.find((them) => exp % them === 0n);
      if (there) {
        exp = exp / there;
        base = pow(base, there);
        return modpow(base, exp, m);
      } else {
        exp = exp - 1n;
        return base * modpow(base, exp, m) % m;
      }
    }
  }

  function menor(x, y) {
    return (x < y) ? x : y;
  }

  function mayor(x, y) {
    return x > y ? x : y;
  }

  function mcd(a, b) {
    let result;
    let [minFactor, maxFactor] = [menor(a, b), mayor(a, b)];
    // this trivial checks avoids div. by zero.
    result = maxFactor;
    while (minFactor !== 0n) {
      maxFactor = result;
      result = minFactor;
      minFactor = maxFactor % minFactor;
    }
    return result;
  }

  function mcm(a, b) {
    return a * b / mcd(a, b);
  }

  // x Luis Bultet Ibles. Cuba, logaritmo. (basado en una versión © 2022 PeakU Inc. All Rights Reserved. Colombia)
  function logaritmo(x, base = null) {
    if (x < 0n) return NaN;

    if (base === null || base === undefined || !base) { // natural
      return Math.log(Number(x));
    }

    switch (base) {
      case 2n:
        return BigInt(Math.log2(Number(x)));
      case 10n:
        return BigInt(Math.log10(Number(x)));
      default:
        return BigInt(Math.log(Number(x))) / BigInt(Math.log(Number(base)));
    }
  }

  function logaritmoEntero(x, base = null) {
    return BigInt(Math.trunc(Number(logaritmo(x, base))));
  }

  // Elevar el número neperiano e a la potencia de x
  function exponent(x) { // fixit
    let e = '27182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664238';
    e.length = Number(menor(BigInt(e.length), Math.round(logaritmo(x, 10))));
    let result = pow(BigInt(e), x);
    result.length = 1 + Math.trunc(Number(x) / x.length);
    return result;
  }

  function exponent(a) {
    let e = '27182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664238';
    const digitosSignificativos = Math.floor(2.302585092994045 * Number(a));
    let ePrima = Number(Math.min(e.substr(0, digitosSignificativos + 1), e.length))
    ; // Recortar la cadena e al número de dígitos significativos

    let result;

    if (BigInt(a) <= BigInt(43)) {
      result = BigInt(Number(a)); // is ok
    } else {
      if (BigInt(a) % BigInt(2) === BigInt(0)) {
        result = BigInt(Number(a) ** BigInt(2)) * BigInt(ePrima) ** BigInt(2);
      } else {
        result = BigInt(Number(a - 1)) * BigInt(ePrima);
      }
    }

    return result;
  }

  // Resolver el problema cuadrático, y devolver las raíces.
  function solveQuadraticProblem(XMasY, XPorY) {
    var result;
    var D1 = pow(XMasY, 2n);
    var D2 = 4n * XPorY;
    var Discriminante = D1 - D2;
    if (Discriminante < 0n) {
      result = []; // NTS en el dominio real
    } else {
      var semiRoot = sqrt(Discriminante) / 2n;
      result = [XMasY - semiRoot, XMasY + semiRoot];
    }
    return result;
  }

  // Resolver una ecuación cuadrática de la forma y = ax² + bx + c, y devolver las raíces.
  function solveQuadraticEquation(a, b, c) {
    let result, root1, root2;
    // calculate discriminant
    let discriminant = b * b - 4n * a * c;
    // condition for real and different roots
    if (discriminant >= 0n) {
      let discRoot = sqrt(discriminant);
      root1 = (-b + discRoot) / (2n * a);
      root2 = (-b - discRoot) / (2n * a);
      result = [root1, root2];
    } else { // if roots are not real
      result = [];
    }
    return result;
  }

  // encuentra [s, t, r] tal que as + bt = d, donde d = mcd(a, b).
  // Mi implementación de una versión del algoritmo en Wikipedia.
  // encuentra [s, t, r] tal que as + bt = d, donde d = mcd(a, b).
  function algoritmoEuclidesExtendido(a, b) {
    let q = [];
    let r = [];
    let s = [];
    let t = [];
    let i;
    r[0] = a;
    s[0] = 1n;
    t[0] = 0n;
    r[1] = b;
    s[1] = 0n;
    t[1] = 1n;
    i = 1;
    while (r[i] !== 0n) {
      q[i] = r[i - 1] / r[i];
      r[i + 1] = r[i - 1] % r[i];
      s[i + 1] = s[i - 1] - q[i] * s[i];
      t[i + 1] = t[i - 1] - q[i] * t[i];
      i++;
    }

    return {x: s[i - 1], y: t[i - 1], z: r[i - 1]};
  }

  // resuelve una ecuación diofántica lineal., encontrar [a, b] tal que ax + by = z
  function diofantic(x, y, z) {
    // Primero se chequea si la ecuación diofántica lineal tiene solución : mcd(x, y) / z ?
    let m_c_d = mcd(x, y);
    if (z % m_c_d !== 0n) {
      return []; // NTS (Bezout condition)
    }
    let q = extendedEuclides(x, y);
    let a = q.x * z / m_c_d;
    let b = q.y * z / m_c_d;
    return [a, b];
  }

  // primes between 0 and 2.000 - this (0..302 elements) list will be helpful 
  // to perform a primitive primality check.
  let primes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n,
    23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n, 101n,
    103n, 107n, 109n, 113n, 127n, 131n, 137n, 139n, 149n, 151n, 157n, 163n, 167n, 173n, 179n,
    181n, 191n, 193n, 197n, 199n, 211n, 223n, 227n, 229n, 233n, 239n, 241n, 251n, 257n, 263n,
    269n, 271n, 277n, 281n, 283n, 293n, 307n, 311n, 313n, 317n, 331n, 337n, 347n, 349n, 353n,
    359n, 367n, 373n, 379n, 383n, 389n, 397n, 401n, 409n, 419n, 421n, 431n, 433n, 439n, 443n,
    449n, 457n, 461n, 463n, 467n, 479n, 487n, 491n, 499n, 503n, 509n, 521n, 523n, 541n, 547n,
    557n, 563n, 569n, 571n, 577n, 587n, 593n, 599n, 601n, 607n, 613n, 617n, 619n, 631n, 641n,
    643n, 647n, 653n, 659n, 661n, 673n, 677n, 683n, 691n, 701n, 709n, 719n, 727n, 733n, 739n,
    743n, 751n, 757n, 761n, 769n, 773n, 787n, 797n, 809n, 811n, 821n, 823n, 827n, 829n, 839n,
    853n, 857n, 859n, 863n, 877n, 881n, 883n, 887n, 907n, 911n, 919n, 929n, 937n, 941n, 947n,
    953n, 967n, 971n, 977n, 983n, 991n, 997n, 1009n, 1013n, 1019n, 1021n, 1031n, 1033n, 1039n,
    1049n, 1051n, 1061n, 1063n, 1069n, 1087n, 1091n, 1093n, 1097n, 1103n, 1109n, 1117n,
    1123n, 1129n, 1151n, 1153n, 1163n, 1171n, 1181n, 1187n, 1193n, 1201n, 1213n, 1217n,
    1223n, 1229n, 1231n, 1237n, 1249n, 1259n, 1277n, 1279n, 1283n, 1289n, 1291n, 1297n,
    1301n, 1303n, 1307n, 1319n, 1321n, 1327n, 1361n, 1367n, 1373n, 1381n, 1399n, 1409n,
    1423n, 1427n, 1429n, 1433n, 1439n, 1447n, 1451n, 1453n, 1459n, 1471n, 1481n, 1483n,
    1487n, 1489n, 1493n, 1499n, 1511n, 1523n, 1531n, 1543n, 1549n, 1553n, 1559n, 1567n,
    1571n, 1579n, 1583n, 1597n, 1601n, 1607n, 1609n, 1613n, 1619n, 1621n, 1627n, 1637n,
    1657n, 1663n, 1667n, 1669n, 1693n, 1697n, 1699n, 1709n, 1721n, 1723n, 1733n, 1741n,
    1747n, 1753n, 1759n, 1777n, 1783n, 1787n, 1789n, 1801n, 1811n, 1823n, 1831n, 1847n,
    1861n, 1867n, 1871n, 1873n, 1877n, 1879n, 1889n, 1901n, 1907n, 1913n, 1931n, 1933n,
    1949n, 1951n, 1973n, 1979n, 1987n, 1993n, 1997n, 1999n];

  // Known Mersenne number exponents until october 2023
  let knownMersenne = [2n, 3n, 5n, 7n, 13n, 17n, 19n, 31n, 61n, 89n, 107n, 127n, 521n, 607n, 1279n, 2203n,
    2281n, 3217n, 4253n, 4423n, 9689n, 9941n, 11213n, 19937n, 21701n, 23209n, 44497n,
    86243n, 110503n, 132049n, 216091n, 756839n, 859433n, 1257787n, 1398269n, 2976221n,
    3021377n, 6972593n, 13466917n, 20996011n, 24036583n, 25964951n, 30402457n, 32582657n,
    37156667n, 42643801n, 43112609n, 57885161n, 74207281n, 77232917n];

  // El próximo pudiera ser 2^82589933-1

  // La hipótesis china (o hipótesis del chino) plantea que:
  // si p es primo y distinto de dos, entonces (2 ^ p) mod p === 2
  function ChinesseHypothesis(p) {
    let result;
    if (p === 2n) {
      result = {primalidad: true, divisor: 2n};
    } else if (p % 2n === 0n) {
      result = {primalidad: false, divisor: 2n};
    } else {
      result = {primalidad: (p === 2n) || (p % 2n === 0n && p !== 2n) && modpow(2n, p, p) === 2n};
    }
    return result;
  }

  // El pequeño teorema de Fermat, el principe de las matemáticas,
  // plantea que: si p es primo, entonces (a ^ (p-1) ) mod p === 1, si mcd(a, p) === 1
  function FermatLitleTheorem(p, base = 2n) {
    let result;
    let m_c_d = mcd(base, p);
    if (m_c_d !== 1n && m_c_d !== p) {
      result = {primalidad: false, divisor: m_c_d};
    } else {
      result = {primalidad: m_c_d === 1n && modpow(base, p, p) === 1n};
    }
    return result;
  }

  // Pequeño teorema de Fermat, no está completo funciona a veces
  function fermat(p, base = 2n, deep = 100n) {
    let result;
    let prueba = FermatLitleTheorem(p, base);
    if (!prueba.primalidad) {
      return prueba.divisor ? prueba.divisor : p;
    }

    // Ya que p es impar, por diferencia de cuadrados: [2^[(p-1)/2] + 1] * [2^[(p-1)/2] - 1] es divisible por p
    let divisor;
    for (let i = 1n; i < deep; i++) {
      divisor = mcd(p, modpow(2n, p + i, p) - i);
      if (divisor !== 1n && divisor !== p && p % divisor === 0n) return menor(divisor, p / divisor);
      divisor = mcd(p, modpow(2n, p - i, p) - i);
      if (divisor !== 1n && divisor !== p && p % divisor === 0n) return menor(divisor, p / divisor);
    }
    return result;
  }

  // Bultet 2023
  function randomBetween(rightPredecessorLimit, leftLimit = 0n) {
    let result = '0';
    for (let i = 0; i < Math.round(BigInt(rightPredecessorLimit - leftLimit).toString().length); i++) {
      result = result + String(Math.trunc(10 * Math.random()));
    }
    let newLength = Math.round(0.5 + Math.random() * BigInt(rightPredecessorLimit - leftLimit).toString().length);
    result = result.substring(newLength);
    return leftLimit + BigInt(result) % (rightPredecessorLimit - leftLimit);
  }

  // return {primalidad: (x % 2 === 0 && x !== 2n) && modpow(a, x, x) === 2n};
  function rabinMiller(n, k = 16) {
    if (n <= 1n) return {primalidad: false, factor: n};
    if (n <= 3n) return {primalidad: true, factor: n};
    if (n % 2n === 0n) return {primalidad: false, factor: 2n};

    let d = n - 1n;
    let s = 0n;

    while (d % 2n === 1n) {
      d /= 2n;
      s += 1;
    }

    for (let i = 0n; i < k; i++) {
      let a = 2n + randomBetween(n - 4n);
      let x = modpow(a, d, n);

      if (x === 1n || x === n - 1n) {
        continue;
      } else {
        let foundDivisor = false;
        let divisor = 1n;

        for (let j = 0n; j < s - 1n; j++) {
          x = modpow(x, 2n, n);

          if (x === 1n) {
            foundDivisor = true;
            divisor = mcd(x - 1n, n);
            break;
          }

          if (x === n - 1n) {
            break;
          }
        }

        if (foundDivisor) {
          return {primalidad: false, factor: divisor};
        }

        if (x !== n - 1n) {
          return {
            primalidad: false,
            factor: 0n,
            hint: 'Se descarta primalidad por variante II (aunque no se determina el factor).',
          };
        }
      }
    }

    return {primalidad: true, factor: 0n, hint: 'Probablemente sea primo (no se determina el factor).'};
  }

  // Terema de Sofía Germain
  function sofie(x) {
    /*
    Teorema de Sophie Germain:
    “To-do número de la forma x^4 + 4, para x distinto de 1; es compuesto.”
    Demostración (para caso particular y = 1 de la identidad).
      x^4 + 4  = x^4 + 4x^2 + 4 - 4x^2
               = (x^2 + 2) (x^2 + 2) - 4x^2 pues lo anterior es un cuadrado perfecto
               = (x^2 + 2) ^2 - 4x^2
               = (x^2 + 2 + 2x) (x^2 + 2 - 2x) y lo anterior es una diferencia de cuadrados.
      Su generalización es la siguiente identidad:
    “Todos los números de la forma: .x^4 + 4y^4 son compuestos, y se descomponen en (x^2 + 2y^2 + 2xy) (x^2 + 2y^2 - 2xy).”
    Veamos nuestra aplicación del teorema, para la factorización de cualquier número:
    Deseas factorizar P, supones que es compuesto, entonces existen X e Y naturales enteros distintos de 1 tales que P = X Y, luego:
    P = X · Y
    P ^ 4 = (X ^ 4) · (Y ^ 4)
    P ^ 4 = (X ^ 4 + 4 - 4) · (Y ^ 4 + 4 - 4)
    P ^ 4 = [(X^2 + 2 + 2X) (X^2 + 2 – 2X) - 4] · [(Y^2 + 2 + YX) (Y^2 + 2 – 2Y) - 4]
    Que debe ser insoluble para P primo, pues en tal caso alguno de X e Y, debería ser igual a 1 que es, precisamente, la excepción del teorema.
    Por tanto, la cuarta potencia de P debería tomar alguna de las formas,
    P^4 = 1 · P^4 ó P^4 = 1 · P^4, (descartada)
    P^4 = P^2 · P^2, (puede descartarse verificando que P no sea un cuadrado perfecto), luego quedaría la última posibilidad:
    P^4 = P^3 · P^1 ó P^4 = P^1 · P^3, para probar esta, basta con asumir:
    P = [(X^2 + 2 + 2X) (X^2 + 2 – 2X) - 4]
    P ^ 3 = (X^2 + 2X + 2) (X^2 – 2X + 2)
    P ^ 3 debería ser más fácilmente factorizable por alguna otra vía, esta incluso; e igualando sus factores a alguna de las dos ecuaciones, pudiera o no, obtenerse uno de los factores de P (X), lo que demostraría o refutaría su primalidad si fuese posible encontrarlo.
    L.Q.Q.D. (Bye)
        * */
    let factor;
    let divisores = [];

    function xplus4facilmente() {
      return primes.some((one) => {
        if (x + 4n % one === 0n) {
          factor = one;
          return true;
        } else {
          return false;
        }
      });
    }

    // factor = (X^2 + 2 – 2X)

  }

  // Función auxiliar para determinar si un número pequeño es primo.
  function esPrimo(numero) {
    if (numero <= 1n) {
      return false;
    }
    if (numero <= 3n) {
      return true;
    }

    if (numero % 2n === 0n || numero % 3n === 0n) {
      return false;
    }

    let i = 5n;
    while (i * i <= numero) {
      if (numero % i === 0n || numero % (i + 2n) === 0n) {
        return false;
      }
      i += 6n;
    }
    return true;
  }

  // (primalidad de números prqueños por fuerza bruta, lenta y exhaustiva)
  function primalidadPorTentativa(x) {
    if (!x || x < 2n) {
      return {primalidad: false, factor: x};
    } else if (x === 2n || x === 3n || x === 5n) {
      return {primalidad: true, factor: x};
    } else if (x % 2n === 0n) {
      return {primalidad: false, factor: 2n};
    } else if (x % 3n === 0n) {
      return {primalidad: false, factor: 3n};
    } else if (x % 5n === 0n) {
      return {primalidad: false, factor: 5n};
    } // Pueden agregarse los criterios de divisibilidad...

    // Ningún número tiene divisores primos por encima de su raiz cuadrada
    let up = sqrt(x);

    // y de paso
    if (x % up === 0n) {
      return primalidadPorTentativa(up);
    }

    let valorInicial = 3n;

    for (var testNo = valorInicial; testNo <= up; testNo += 2n) {
      if (x % testNo === 0n) {
        return {primalidad: false, factor: testNo};
      }
    }
    return {primalidad: true, factor: x};
  }

  // Encontrar factor utilizando el inverso multiplicativo, implementación de: algoritmo de factorización.txt
  // Optimizar
  function primality(x) {
    // Definición de constantes, tipos, variables,
    // etiquetas y subprogramas.

    // Known Mersenne number exponents until october 2023
    let knownMersenne = [2n, 3n, 5n, 7n, 13n, 17n, 19n, 31n, 61n, 89n, 107n, 127n, 521n, 607n, 1279n, 2203n,
      2281n, 3217n, 4253n, 4423n, 9689n, 9941n, 11213n, 19937n, 21701n, 23209n, 44497n,
      86243n, 110503n, 132049n, 216091n, 756839n, 859433n, 1257787n, 1398269n, 2976221n,
      3021377n, 6972593n, 13466917n, 20996011n, 24036583n, 25964951n, 30402457n, 32582657n,
      37156667n, 42643801n, 43112609n, 57885161n, 74207281n, 77232917n, 82589933n];

    // Retorna [(base^exp) + d] mod m
    // Se deduce aplicando el teorema chino de los restos
    // El argumento d puede ser negativo, en particular -1, para chequear divisibilidad
    // de expresiones de esta clase y (también conveniente para chequear la igualdad de un
    // m ≠ 1 con un número de Mersenne, dado su exponente sin necesidad de instanciarlo).
    function modpowplus(base, exp, d, m) {
      // Resto de la division base^exp mod m
      function modpow(base, exp, m) {
        let result = 1n;
        while (exp > 0n) {
          if ((exp & 1n) === 1n) {
            result = (result * base) % m;
          }
          exp = exp >> 1n;
          base = (base * base) % m;
        }
        return result;
      }

      let result = (modpow(base, exp, m) + d) % m;
      return result < 0n ? (m + result) % m : result;
    }

    // Función auxiliar para calcular el máximo común divisor (GCD) entre dos números
    function gcd(a, b) {
      if (b === 0n) {
        return a;
      }
      return gcd(b, a % b);
    }

    // De otro modo, encontrar el número de Mersenne i
    // tal que Mersenne(i) sea mayor o igual al logaritmo entero de (x + 1).

    function logaritmoEntero(x, base = null) {
      // x Luis Bultet Ibles. Cuba, logaritmo. (basado en una versión © 2022 PeakU Inc. All Rights Reserved. Colombia)
      function logaritmo(x, base = null) {
        if (x < 0n) return NaN;
        if (base === null || base === undefined || !base) { // natural
          return Math.log(Number(x));
        }
        switch (BigInt(base)) {
          case 2n:
            return Math.log2(Number(x));
          case 10n:
            return Math.log10(Number(x));
          default:
            return Math.log(Number(x)) / Math.log(Number(base));
        }
      }

      return BigInt(Math.trunc(Number(logaritmo(x, base))));
    }

    // Calcular el resto (a % (a - x)) y almacenarlo en la variable b.
    function inversoMultiplicativo(a, m) {
      // encuentra [s, t, r] tal que as + bt = d, donde d = mcd(a, b).
      // Mi implementación de una versión del algoritmo en Wikipedia.
      // encuentra [s, t, r] tal que as + bt = d, donde d = mcd(a, b).
      function algoritmoEuclidesExtendido(a, b) {
        let q = [];
        let r = [];
        let s = [];
        let t = [];
        let i;
        r[0] = a;
        s[0] = 1n;
        t[0] = 0n;
        r[1] = b;
        s[1] = 0n;
        t[1] = 1n;
        i = 1;
        while (r[i] !== 0n) {
          q[i] = r[i - 1] / r[i];
          r[i + 1] = r[i - 1] % r[i];
          s[i + 1] = s[i - 1] - q[i] * s[i];
          t[i + 1] = t[i - 1] - q[i] * t[i];
          i++;
        }
        return {x: s[i - 1], y: t[i - 1], z: r[i - 1]};
      }

      let {x, y, gcd} = algoritmoEuclidesExtendido(a, m);
      let result;
      if (gcd !== 1n) {
        // "No existe el inverso, por la condición de Bezout."
        result = null;
      } else {
        x = (x % m + m) % m;
        result = x;
      }
      return result;
    }

    let result = {factor: x, primalidad: false};
    // Inicializar la variable a como 2.
    let a = 2n;
    // Si x es par, devolver 2 como divisor de x.
    if (!x || x < 2n) {
      result = {factor: x, primalidad: false};
    } else {
      // Si x es alguno de los números de Mc (Mersenne conocidos),
      // o si 2^(Mc) - 1 mod x = 0, devolver 2^(Mc) - 1.
      if (knownMersenne.some((m) => {
        if (x % BigInt(m) === 0n) {
          result.factor = BigInt(m);
          return true;
        } else {
          let _mcd = gcd(x, modpowplus(2n, m, -1n, x));
          if (_mcd > 1n && _mcd < x && x % _mcd === 0n) {
            result.factor = _mcd;
            return true;
          } else {
            _mcd = gcd(x, modpowplus(2n, m, 1n, x));
            if (_mcd > 1n && _mcd < x && x % _mcd === 0n) {
              result.factor = _mcd;
              return true;
            }
          }
          return false;
        }
      })) {
        result.primalidad = result.factor === x;
      } else {
        // Y con todos los números de Mersenne menores que el número
        let maximo = knownMersenne[knownMersenne.length - 1];
        for (let i = 2n; i <= maximo; i = i + 1n) {
          console.log(`${i} de ${maximo}.`);
          _mcd = gcd(x, modpowplus(2n, i, 1n, x));
          if (_mcd > 1n && _mcd < x && x % _mcd === 0n) {
            result.factor = _mcd;
            break;
          }
          _mcd = gcd(x, modpowplus(2n, i, -1n, x));
          if (_mcd > 1n && _mcd < x && x % _mcd === 0n) {
            result.factor = _mcd;
            break;
          }
        }
      }
    }
    result.primalidad = result.factor === x;
    return result;
  }

  // Original version from ChatGPT
  function inmaculatedPollardRho(n) {
    if (n < 2n) {
      return {primalidad: false, factor: n};
    } else if (n % 2n === 0n) {
      return {primalidad: n === 2n, factor: 2n};
    }

    let a = 2n;
    let b = 2n;
    let divisor = 1n;

    while (divisor === 1n) {
      a = (a * a + 1n) % n;
      b = (b * b + 1n) % n;
      b = (b * b + 1n) % n;

      if (b > a) {
        divisor = mcd(n + a - b, n); // with this improve, to avoid negative result's.
      } else {
        divisor = mcd(a - b, n);
      }
    }

    return {primalidad: divisor === 1n || divisor === n, factor: divisor === 1n ? n : divisor};
  }

  // Implementación del algoritmo de Pollard Rho para factorización de números enteros
  function pollardRho(n, verbose = false) {
    if (n < 2n) {
      return {primalidad: false, factor: n};
    } else if (n % 2n === 0n) {
      return {primalidad: n === 2n, factor: 2n};
    }

    let a = 2n;
    let b = 2n;
    let divisor = 1n;

    // Bultet cycle detection
    let cycle = false;
    let a0;
    let b0;

    while (divisor === 1n) {
      a = (a * a + 1n) % n;
      b = (b * b + 1n) % n;
      b = (b * b + 1n) % n;

      if (b > a) {
        divisor = mcd(n + a - b, n); // to avoid negative result's
      } else {
        divisor = mcd(a - b, n);
      }

      // cycle detection
      if (!cycle) {
        a0 = a;
        b0 = b;
        cycle = true;
      } else if (a === a0 && b === b0) {
        break;
      }

      if (verbose) console.warn(`d = ${divisor}, x = ${a}, y = ${b}`);
    }

    return {primalidad: divisor === 1n || divisor === n, factor: divisor === 1n ? n : divisor};
  }

  // Las mejoras de Richard Brent

  // Ejemplo de uso:

  // Pueden utilizarse además del cuadrático
  let polinomioCuadratico = (x, n) => (x * x + 1n) % n;
  let polinomioCubico = (x, n) => (x * x * x + x * x + 1n) % n;
  let polinomioGrado4 = (x, n) => (pow(x, 4n) + pow(x, 3n) + pow(x, 2n) + 1n) % n;

  // Ejemplo de uso:
  // pollardRhoBrent(123456789n, polinomioCuadratico, true);
  function pollardRhoBrent(n, polinomyCallback = polinomioCuadratico, verbose = false) {
    let a = 2n;
    let b = 2n;

    function mcd(a, b) {
      while (b !== 0n) {
        let t = b;
        b = a % b;
        a = t;
      }
      return a;
    }

    let cycle = false;
    let a0, b0;

    while (true) {
      a = polinomyCallback(a, n);
      b = polinomyCallback(polinomyCallback(b, n), n);

      if (a > b) {
        divisor = mcd(a - b, n);
      } else if (a < b) {
        divisor = mcd(b - a, n);
      } else {
        divisor = n;
        break;
      }

      if (!cycle) {
        a0 = a;
        b0 = b;
        cycle = true;
      } else if (a === a0 && b === b0) {
        break;
      }

      if (verbose) console.warn(`d = ${divisor}, x = ${a}, y = ${b}`);
    }

    return {primalidad: divisor === 1n || divisor === n, factor: divisor === 1n ? n : divisor};
  }


  // Algoritmo de factorización de Pollard p-1
  function factorizacionPollardPMinusOne(n, maxIterations = 100) {
    let a = 2n;
    let b = modpow(a, n - 1n, n);
    let d = mcd(b - 1n, n);

    for (let i = 2; i <= maxIterations; i++) {
      a = modpow(a, BigInt(i), n);
      b = modpow(a, n - 1n, n);
      d = mcd(b - 1n, n);
      if (1n < d && d < n) {
        return d;
      }
      if (d === n) {
        break;
      }
    }

    return n;
  }

  /*

  La de reciprocidad bicuadrática es una ley matemática que establece una relación entre los residuos cuadráticos módulo
  p y módulo q, dos números primos impares. En concreto, establece que para cualquier número primo impar p y cualquier
  número entero a que no es múltiplo de p, se tiene que:

    (a/p)(p/a) = (-1)^([(p-1)/2][(a-1)/2])

  donde (a/p) es un símbolo de Legendre y [x] representa la parte entera de x.

  Esta ley tiene múltiples aplicaciones en la teoría de números y es utilizada, por ejemplo, en la criptografía para el
  diseño de algoritmos de encriptación seguros.

  */
  function leyReciprocidadBicuadratica(n) {
    const num = BigInt(n);
    const legendre = BigInt(2) ** ((num ** BigInt(2) - BigInt(1)) / BigInt(8));

    if (num % BigInt(4) === BigInt(1) || num % BigInt(4) === BigInt(2)) {
      return 'No se puede aplicar la ley de reciprocidad bicuadrática para este número.';
    } else if (legendre === BigInt(1) || legendre === num - BigInt(1)) {
      return 'El símbolo de Legendre de ' + num + ' es 1';
    } else {
      return 'El símbolo de Legendre de ' + num + ' es -1';
    }
  }

  /*

  La ley de reciprocidad cuadrática establece que si p y q son números primos impares distintos, entonces el símbolo de
  Jacobi de p respecto a q es igual al símbolo de Jacobi de q respecto a p, excepto cuando tanto p como q sean congruentes
  a 3 modulo 4, en cuyo caso los signos son opuestos. Esta ley es una generalización de la ley de reciprocidad cuadrática
  de Euler. El símbolo de Jacobi es una generalización del símbolo de Legendre que permite calcular el número de soluciones
  de la ecuación cuadrática x^2 ≡ a (mod p), donde a es un número entero y p es un número primo impar.

  */

  function jacobiSymbol(a, n) {
    // Convertir los parámetros a BigInt si no lo son
    a = BigInt(a);
    n = BigInt(n);

    // Verificar que 'n' sea mayor que 0 e impar
    if (n <= 0n || n % 2n === 0n) {
      throw new Error('El segundo parámetro \'n\' debe ser mayor que 0 e impar');
    }

    // Calcular el símbolo de Jacobi
    let result = 1n;
    while (a !== 0n) {
      while (a % 2n === 0n) {
        a /= 2n;
        const r = n % 8n;
        if (r === 3n || r === 5n) {
          result = -result;
        }
      }
      [a, n] = [n, a]; // Intercambiar valores
      if (a % 4n === 3n && n % 4n === 3n) {
        result = -result;
      }
      a %= n;
    }

    if (n === 1n) {
      return result;
    }

    return 0n;
  }

  function quadraticReciprocity(p, q) {
    // Convertir los parámetros a BigInt si no lo son
    p = BigInt(p);
    q = BigInt(q);

    // Verificar que 'p' y 'q' sean primos entre sí
    if (jacobiSymbol(p, q) !== 1n || jacobiSymbol(q, p) !== 1n) {
      throw new Error('Los números \'p\' y \'q\' no son primos entre sí');
    }

    // Verificar que 'p' y 'q' sean primos impares
    if (p < 3n || q < 3n || p % 2n === 0n || q % 2n === 0n) {
      throw new Error('Los números \'p\' y \'q\' deben ser primos impares');
    }

    let result;
    if (p % 4n === 1n || q % 4n === 1n) {
      result = 'La ley de reciprocidad cuadrática se cumple';
    } else {
      result = 'La ley de reciprocidad cuadrática no se cumple';
    }

    return result;
  }


  // Implementación del algoritmo de la curva elíptica de Lenstra (ECM) by ChatGPT
  function lenstraECM(n) {

    function ecmFactor(n) {

      // Función auxiliar para calcular el máximo común divisor (GCD) entre dos números
      function gcd(a, b) {
        if (b == 0) {
          return a;
        }
        return gcd(b, a % b);
      }

      // Función auxiliar para calcular el inverso multiplicativo de un número módulo n
      function modInverse(a, n) {
        let t = 0,
          newt = 1,
          r = n,
          newr = a;

        while (newr !== 0) {
          let quotient = Math.floor(r / newr);
          [t, newt] = [newt, t - quotient * newt];
          [r, newr] = [newr, r - quotient * newr];
        }

        if (t < 0) {
          t = t + n;
        }

        return t;
      }

      // Verificar si n es un número primo
      function isPrime(n) {
        if (n <= 1) {
          return false;
        }
        if (n <= 3) {
          return true;
        }
        if (n % 2 === 0 || n % 3 === 0) {
          return false;
        }

        let i = 5;
        while (i * i <= n) {
          if (n % i === 0 || n % (i + 2) === 0) {
            return false;
          }
          i += 6;
        }

        return true;
      }

      // Calcular el punto P = a * P en la curva elíptica definida por y^2 ≡ x^3 + ax + b (mod n)
      function multiplyPoint(a, b, n, P) {
        if (P === null) {
          return null;
        }

        const [x, y] = P;
        let slope, newX, newY;

        if (y === 0) {
          return null;
        }

        slope = ((3 * x * x + a) * modInverse(2 * y, n)) % n;
        newX = (slope * slope - 2 * x) % n;
        newY = (slope * (x - newX) - y) % n;

        return [newX, newY];
      }

      // Generar un punto inicial aleatorio en la curva elíptica definida por y^2 ≡^3 + ax + b (mod n)
      function generateRandomPoint(a, b, n) {
        const x = Math.floor(Math.random() * n);
        const y2 = (x * x * x + a * x + b) % n;
        const y = Math.sqrt(y2);
        return [x, y];
      }

      if (isPrime(n)) {
        return n; // Si n es primo, no se puede factorizar
      }

      // Intentar encontrar un factor utilizando el algoritmo de Lenstra (ECM)
      let a = 1,
        b = 1,
        P = generateRandomPoint(a, b, n);

      while (P !== null) {
        if (gcd(2 * P[1], n) !== 1) {
          return gcd(2 * P[1], n); // Encontró un factor
        }
        a++;
        b = (P[0] * P[0] - n) / (a * a); // Calcular b = (x^2 - n) / a^2
        P = multiplyPoint(a, b, n, P); // Calcular el siguiente punto
      }

      return null; // No se pudo encontrar un factor
    }

    // Llamar al algoritmo de la curva elíptica de Lenstra (ECM)
    return ecmFactor(n);
  }

  // Funciones de aritmética modular

  // Función para obtener a mod (c**d)
  function modBigInt(a, c, d) {
    if (d === 0n) {
      return 1n;
    }

    // Reducir a mediante el módulo c^d
    a = a % (c ** d);
    let result = 1n;

    while (d > 0n) {
      // Si el bit menos significativo de d es 1, multiplicar resultado por a
      if (d & 1n) {
        result = (result * a) % (c ** d);
      }

      // Reducir a mediante el módulo c^d
      a = (a * a) % (c ** d);
      d >>= 1n; // Dividir d entre 2
    }

    return result;
  }

  // Función para obtener (a**b) mod (c**d)
  function powerModBigInt(a, b, c, d) {
    let result = 1n;

    while (b > 0n) {
      // Si el bit menos significativo de b es 1, multiplicar resultado por a
      if (b & 1n) {
        result = (result * a) % (c ** d);
      }

      // Reducir a mediante el módulo c^d
      a = (a * a) % (c ** d);
      b >>= 1n; // Dividir b entre 2
    }

    return result;
  }

  // Función para obtener (a**b + e) mod (c**d + f)
  function powerModPlusBigInt(a, b, e, c, d, f) {
    let result = 1n;

    while (b > 0n) {
      // Si el bit menos significativo de b es 1, multiplicar resultado por a
      if (b & 1n) {
        result = (result * a) % (c ** d);
      }

      // Reducir a mediante el módulo c^d
      a = (a * a) % (c ** d);
      b >>= 1n; // Dividir b entre 2
    }

    // Sumar e al resultado y reducir mediante el módulo c^d + f
    result = (result + e) % (c ** d + f);

    return result;
  }


  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarUnFactorPrimo(decimal) {
    decimal = String(decimal).trim();

    // hasta 18 dígitos...
    let valorEnteroGrande = BigInt(decimal);
    if (decimal.length < 18) {
      return primalidadPorTentativa(valorEnteroGrande).factor;
    }

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (valorEnteroGrande < 4n) {
      return resultado;
    }

    // Pruebas extras

    // Es divisible por uno de los primeros 300 números primos
    let there = primes.findIndex((them) => valorEnteroGrande % them === 0n);
    if (there !== -1) {
      return primes[there];
    }

    // Es un cuadrado perfecto? (solamente pueden serlo los de la forma 4s o 4s + 1.)
    function isAPerfectSquare(s) {
      let mod4 = s % 4n;
      if (mod4 !== 0n || mod4 !== 1n) {
        return false;
      }
      return s === pow(sqrt(s), 2n);
    }

    // this return [(base^exp) - d] mod m
    // I deduced it by applying the Chinese remainder theorem
    function modpowplus(base, exp, d, m) {
      return (m + d + modpow(base, exp, m)) % m; // m added to induce positive results.
    }

    // Es múltiplo o alguno de los primos de Mersenne conocidos hasta 2023 (Just fix this section, to improve performance).
    // if (valorEnteroGrande % 2n === 0n) return 2n;

    // for (let noMercy = 0; noMercy < logaritmo(valorEnteroGrande, 2n); noMercy++) {
    //   let exponent = knownMersenne[noMercy];
    //   let rest = modpowplus(2n, exponent, -1n, valorEnteroGrande);
    //   rest--;
    //   if (mcd(rest, valorEnteroGrande) === 0n) {
    //     return pow(2n, exponent) - 1n;
    //   } else {
    //     while (rest !== 1n) {
    //       // ¿Es un cuadrado perfecto?
    //       if (exponent % 2n === 0n && isAPerfectSquare(rest)) {
    //         return pow(2n, exponent / 2n) - sqrt(rest);
    //       }
    //       rest = mcd(valorEnteroGrande, rest);
    //       if (rest !== 1n && rest !== valorEnteroGrande && valorEnteroGrande % rest === 0n) {
    //         return rest;
    //       }
    //     }
    //   }
    // }

    let raizCuadrada = sqrt(valorEnteroGrande);
    if (raizCuadrada >= 2n && valorEnteroGrande % raizCuadrada === 0n) {
      return encontrarUnFactorPrimo(raizCuadrada);
    }

    let factorFermat = fermat(valorEnteroGrande);
    if (factorFermat >= 2n && factorFermat !== valorEnteroGrande && valorEnteroGrande % factorFermat === 0n) {
      return menor(factorFermat, valorEnteroGrande / factorFermat);
    }

    // elimina esto para activar el código de abajo, utilízalo en un mejor lugar.
    // return pollardRho(valorEnteroGrande).factor;
    return numberFieldSieveWithIterations(valorEnteroGrande);

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => {
          return element[0] === par[0] && element[1] === par[1];
        },
      );
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos

    function agregarCandidatosDeFactores(factor1, factor2) {
      let notDivisorFoundResult = 0n;
      // si no existe el par en la lista agrégalo (si no exceden la raíz cuadrada)
      [factor1, factor2] = [menor(factor1, factor2), mayor(factor1, factor2)];
      let subProd = BigInt(factor1) * BigInt(factor2);

      if (existsCandidates([factor1, factor2]) || subProd > valorEnteroGrande || (factor1.length + factor2.length > decimal.length) || BigInt(factor1) > raizCuadrada || BigInt(factor2) > raizCuadrada) {
        return notDivisorFoundResult;
      }

      if (BigInt(factor1) !== 1n && BigInt(factor2) !== 1n && BigInt(factor1) !== valorEnteroGrande && BigInt(factor2) !== valorEnteroGrande) {
        if (valorEnteroGrande % BigInt(factor1) === 0n) {
          return factor1;
        } else if (valorEnteroGrande % BigInt(factor2) === 0n) {
          return factor2;
        }
      }

      if (coincidenciasAlFinal(decimal, subProd.toString()) >= subProd.toString().length - 3) {
        candidatos.push([factor1, factor2]);
      }

      return notDivisorFoundResult;
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(1, decimal);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores('1', '1');
        agregarCandidatosDeFactores('3', '7');
        agregarCandidatosDeFactores('9', '9');
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores('1', '3');
        agregarCandidatosDeFactores('7', '9');
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores('1', '7');
        agregarCandidatosDeFactores('3', '9');
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores('1', '9');
        agregarCandidatosDeFactores('3', '3');
        agregarCandidatosDeFactores('7', '7');
        break;
      }
    }

    function menorFactor(b) {
      let a = valorEnteroGrande / BigInt(b);

      // Es recursiva, primero sácale presión a la caldera
      candidatos = [];

      x = encontrarUnFactorPrimo(a);
      y = encontrarUnFactorPrimo(b);

      return menor(x, y);
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    raizCuadrada = sqrt(valorEnteroGrande);

    if (candidatos.length > 0) {
      do {

        let parEnAnalisis = [0, 0];

        // Se toma un par desde el final
        parEnAnalisis = [candidatos[candidatos.length - 1][0], candidatos[candidatos.length - 1][1]];
        candidatos.length = candidatos.length - 1;

        // Se toma el índice del candidato más corto del par (como cadenas para incluir los ceros)
        let via = parEnAnalisis[0].length < parEnAnalisis[1].length ? 0 : 1;

        // Se convierten las propuestas a enteros grandes, para eliminar ceros a la izquierda
        let propuesta1 = BigInt(parEnAnalisis[via]);
        let propuesta2 = BigInt(parEnAnalisis[1 - via]);

        //
        // console.log(`Analizando ${[propuesta1, propuesta2]}, de ${candidatos.length} (multiplican ${BigInt(propuesta1) * BigInt(propuesta2)}).`);

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (propuesta1 !== 1n && propuesta1 !== valorEnteroGrande && valorEnteroGrande % propuesta1 === 0n) {
          return propuesta1.toString();
        } else if (propuesta2 !== 1n && propuesta2 !== valorEnteroGrande && valorEnteroGrande % propuesta2 === 0n) {
          return propuesta2.toString();
        }

        // Se agregan ceros a la izquierda
        // Siempre que los últimos dígitos del producto coincidan

        for (let digito1 = 0; digito1 < 10; digito1++) {
          for (let digito2 = 0; digito2 < 10; digito2++) {
            let div = agregarCandidatosDeFactores(String(digito1) + parEnAnalisis[via], String(digito2) + parEnAnalisis[1 - via]);
            if (div !== 0n) {
              return div;
            }
          }
        }


      } while (candidatos.length > 0) ;
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  function encontrarElMenorFactorPrimo(decimal) {
    let primero = BigInt(encontrarUnFactorPrimo(decimal)); // inclusive un divisor cualquiera, no necesariamente primo
    if (primero > 1n && primero !== BigInt(decimal)) {
      let segundo = BigInt(encontrarUnFactorPrimo((BigInt(decimal) / primero).toString()));
      return menor(primero, segundo);
    } else {
      return BigInt(primero);
    }
  }


  function otroMetodoFactorizacion(x) {
    // Raise the base at the power of exponent
    return 1;
  }

  // Una solución elegante de Mauricio Contreras, https://es.stackoverflow.com/users/112837/mauricio-contreras
  // en https://es.stackoverflow.com/questions/236576/descomponer-n%C3%BAmero-entero-en-factores-primos-con-javascript
  // que porteamos a BigInt y a la que llamamos:
  function teoremaGeneralDeLaAritmetica(n, sintaxisExtendida = false) {
    let resultado = []; // aqui almacenaremos los factores de forma más legible
    if (n === 0n || n === 1n) {
      resultado = sintaxisExtendida && n === 1n ? [{factor: 2n, exponente: 0n}] : [{factor: n, exponente: 1n}];
    } else {
      let arr = []; //aqui almacenamos los factores temporalmente
      let division = n;// el primer valor que usaremos es N
      while (division > 1n) { // 'resultado' irá variando hasta hacerse 1
        let divisor = encontrarUnFactorPrimo(division);
        division = division / divisor; // actualizamos el valor de la división
        arr.push(divisor);
      }
      let factor = arr[0]; // almacenamos el primer valor
      let cont = 1n; // instanciamos la cantidad de veces que aparece el primer elemento
      if (arr.length > 1) { // si hay más de 1 elemento en el array
        for (let i = 1; i < arr.length; i++) {
          if (factor !== arr[i]) { // si el factor cambia, ya no se repite más, podemos almacenarlo
            resultado.push({factor: factor, exponente: cont});
            factor = arr[i]; // establecemos el nuevo factor
            cont = 0n; // inciamos el contador en cero, en la siguiente línea aumentará 1
          }
          cont++; // si el factor se repite, aumentamos el contador, si estaba en cero se aumenta a 1
        }
        resultado.push({factor: factor, exponente: cont}); // almacenamos el último factor encontrado
      } else { // en caso de que N sea primo, solo tiene un factor
        resultado.push({factor: factor, exponente: cont});
      }
      if (!sintaxisExtendida) {
        resultado = [{factor: 1n, exponente: 1n}].concat(resultado); // El 1 los divide a todos
      }
    }
    return resultado;
  }

  // Presentar una factorización del número, en formato humano. (arreglar)
  function factorizacion(s, compresion = false, espaciado = ' ') {

    function formatearPrimerFactor(a) {
      let divisor;
      let exponente = '1';
      let result;
      let residuo;
      if (a === '1') {
        divisor = '2';
        exponente = '0';
      } else if (a === '0') {
        divisor = '0';
        exponente = '1';
      } else {
        exponente = '0';
        divisor = encontrarUnFactorPrimo(a);
        if (a === divisor) {
          divisor = a;
          exponente = '1';
        } else {
          [a, residuo] = [(BigInt(a) / BigInt(divisor)).toString(), (BigInt(a) % BigInt(divisor)).toString()];
          while (residuo === '0' && a !== '1') {
            [a, residuo] = [(BigInt(a) / BigInt(divisor)).toString(), (BigInt(a) % BigInt(divisor)).toString()];
            exponente = (BigInt(exponente) + 1n).toString();
          }
        }
      }
      return [divisor, exponente];
    }

    let result;
    let divisorPrimo, exponente;
    let dummyrest;
    let temporal;

    result = s;
    if (BigInt(s) < 3n) return result;

    result = '1';
    do {
      do {
        [divisorPrimo, exponente] = formatearPrimerFactor(s);
        if (exponente !== '1') {
          if (exponente !== '2') {
            result = result + espaciado + 'x' + espaciado + divisorPrimo + '²';
          } else if (exponente === '3') {
            result = result + espaciado + 'x' + espaciado + divisorPrimo + '³';
          } else if (compresion) {
            function modoRecursivo(s) {
              if (divisorPrimo === s) {
                return s;
              } else {
                return '(' + factorizacion(s, compresion, espaciado) + ')';
              }
            }

            result = result + espaciado + 'x' + espaciado + ('(' + modoRecursivo(divisorPrimo) + espaciado + '^' + espaciado + modoRecursivo(exponente) + ')');
          } else {
            result = result + espaciado + 'x' + espaciado + ('(' + divisorPrimo + espaciado + '^' + espaciado + exponente + ')');
          }
        } else {
          result = result + espaciado + 'x' + espaciado + divisorPrimo;
        }
        [s, dummyRest] = [(BigInt(s) / (BigInt(divisorPrimo) ** BigInt(exponente))).toString(), (BigInt(s) % (BigInt(divisorPrimo) ** BigInt(exponente))).toString()];
      } while ((s !== '1') && (s !== '1') && (dummyRest === '0'));
      // pon esto
      // s := Dividir(s, Potencia(pdi, pws), dummyRest);
    } while (s !== '0' && s !== '1');
    return result;
  }


  ////////////////

  // Fix this...
  function humanExposition(entero, html = true, compression = false) {

    // process id
    let processName = `Factorización del número ${entero}`;

    // Comienzo de la sección crítica
    console.time(processName);

    // llamamos a la función que calcula los factores primos
    let factoresPrimos = teoremaGeneralDeLaAritmetica(entero);

    console.timeEnd(processName);
    // Fin de la sección crítica

    // construimos el string del resultado
    let resultado = '';
    for (let i = 0; i < factoresPrimos.length; i++) {
      let factor = factoresPrimos[i].factor.toString();
      let exponente = factoresPrimos[i].exponente.toString();
      if (compression && factoresPrimos[i].exponente > 1n) {
        exponente = humanExposition(factoresPrimos[i].exponente, html, compression);
      }
      //usaremos el 'tag' <sup> de HTML
      if (html) {
        resultado += factor + '<sup>' + exponente + '</sup>' + (i < factoresPrimos.length - 1 ? ' x ' : '');
      } else {
        exponente = exponente !== '1' ? '^(' + exponente + ') ' : '';
        resultado += factor + exponente + (i < factoresPrimos.length - 1 ? ' x ' : '');
      }
    }

    // let resultado = '';
    // // construimos el string del resultado
    // for (let i = 0; i < factoresPrimos.length; i++) {
    //   if (html) { // si usamos el 'tag' <sup> de HTML
    //     resultado += (factoresPrimos[i].factor).toString();
    //     +'<sup>'
    //     + compression && factoresPrimos.length > 1 ? humanExposition((BigInt(factoresPrimos[i].exponente)), html, compression) : (factoresPrimos[i].exponente).toString()
    //       + '</sup>' + (i < factoresPrimos.length - 1 ? ' x ' : '');
    //   } else {
    //     resultado += (factoresPrimos[i].factor).toString()
    //     + compression && factoresPrimos.length > 1 ? humanExposition((BigInt(factoresPrimos[i].exponente)), html, compression) : (factoresPrimos[i].exponente).toString()
    //       + (i < factoresPrimos.length - 1 ? ' x ' : '');
    //   }
    // }
    return resultado;
  }

  function calcular(entero) {
    //instanciamos el elemento de salida
    let salida = document.getElementById('salida');

    let compresion = document.getElementById('compresionCheckButton').checked;

    let infija = document.getElementById('infija').checked;

    // escribimos la salida
    salida.innerHTML = 'La descomposición en factores de ' + entero.toString() + ' = ' + humanExposition(entero, infija, compresion);
  }

  ///////////////////////


  // remove this line when fix encontrarMenorFactorPrimo and factorización
  // test();

  // Contiene la solución clásica (ignora la función)
  function lucaslucas1() {
    // ok
    function lucasLehmerTest(p) {
      let s = BigInt(4);
      const m = BigInt(2) ** BigInt(p) - BigInt(1);

      for (let i = 0; i < p - 2; i++) {
        s = (s ** BigInt(2) - BigInt(2)) % m;
      }

      return s === BigInt(0);
    }

    function isPrime(p) {
      if (p === 2) return true;

      if (p < 2 || p % 2 === 0) return false;

      const limit = BigInt(Math.sqrt(p));
      for (let i = BigInt(3); i <= limit; i += BigInt(2)) {
        if (p % i === BigInt(0)) return false;
      }

      return lucasLehmerTest(p);
    }

    const p = BigInt('521');
    console.log(`¿El número p=${p} es primo? ${isPrime(p)}`);
  }

  // Contiene la solución mejorada (ignora la función)
  function lucaslucas2() {


    function lucasLehmerTest2(p) {

      // Función para obtener a mod (c**d)
      function modBigInt(a, c, d) {
        if (d === 0n) {
          return 1n;
        }

        // Reducir a mediante el módulo c^d
        a = a % (c ** d);
        let result = 1n;

        while (d > 0n) {
          // Si el bit menos significativo de d es 1, multiplicar resultado por a
          if (d & 1n) {
            result = (result * a) % (c ** d);
          }

          // Reducir a mediante el módulo c^d
          a = (a * a) % (c ** d);
          d >>= 1n; // Dividir d entre 2
        }

        return result;
      }

      let s = modBigInt(4n, 2n ** BigInt(p) - 1n, BigInt(p));
      const m = 2n ** BigInt(p) - 1n;

      for (let i = 0; i < p - 2n; i++) {
        s = modBigInt((s ** 2n - 2n), m, BigInt(p));
      }

      return s === 0n;
    }
  }

  // Según ChatGPT: aquí tienes una implementación en JavaScript para encontrar un factor primo de un argumento BigInt utilizando el algoritmo de Criba Cuadrática:


  // Función para encontrar un factor primo utilizando la Criba Cuadrática
  function quadraticSieve(n) {
    /*
        Documentación, según Wikipedia:

        El algoritmo de criba cuadrática (QS del inglés quadratic sieve), es un algoritmo de factorización de enteros y,
       en la práctica, el segundo método más rápido conocido (después de la criba general del cuerpo de números).
       Es todavía el más rápido para enteros que tienen 100 o menos dígitos decimales, y es considerado mucho más
       sencillo que la criba de cuerpos numéricos. Es un algoritmo de factorización de propósito general, lo que
       significa que su tiempo de ejecución únicamente depende el tamaño del entero a ser factorizado, y no sobre
       una estructura especial o propiedades. Fue inventado por Carl Pomerance en 1981 como una mejora a la criba lineal
       de Schroeppel.

    */

    // Declaración de miembros: constantes, tipos, variables, etiquetas
    // y subfunciones de la función quadraticSieve.

    // Función para calcular el máximo común divisor
    function gcd(a, b) {
      if (b === 0n) {
        return a;
      }
      return gcd(b, a % b);
    }

    // Función para calcular el módulo cuadrado
    function squareMod(n, m) {
      let tmpRest = n % m;
      return (tmpRest * tmpRest) % m;
    }

    // Función para calcular el símbolo de Legendre
    function legendreSymbol(a, p) {
      const ls = squareMod(a, p);
      if (ls === 1n) {
        return 1n;
      } else if (ls === p - 1n) {
        return -1n;
      }
      return 0n;
    }

    // Función para calcular el símbolo de Jacobi
    function jacobiSymbol(a, n) {
      if (a === 0n) {
        return n === 1n ? 1n : 0n;
      } else if (a === 2n) {
        const mod8 = n % 8n;
        if (mod8 === 1n || mod8 === 7n) {
          return 1n;
        } else if (mod8 === 3n || mod8 === 5n) {
          return -1n;
        }
        return 0n;
      } else if (gcd(a, n) !== 1n) {
        return 0n;
      }

      let e = 0n;
      let m = n - 1n;
      while (m % 2n === 0n) {
        m /= 2n;
        e++;
      }

      let v = squareMod(a, n);
      for (let i = 1n; i <= e / 2n; i++) {
        const prevV = v;
        v = squareMod(v, n);
        if (v === 1n && prevV !== 1n && prevV !== n - 1n) {
          return 0n;
        }
      }

      return v === 1n ? 1n : -1n;
    }

    // Cuerpo o implementación de la función quadraticSieve.
    {
      const sqrtN = sqrt(n);

      // Verificar si n es un cuadrado perfecto
      if (sqrtN * sqrtN === n) {
        return sqrtN;
      }

      let a = 2n;
      while (true) {
        const b = jacobiSymbol(a * a - n, n);
        if (b !== -1n) {
          const factor = gcd(a - b, n);
          if (factor !== 1n && factor !== n) {
            return factor;
          }
        }
        a++;
      }
    }
  }

  // Esta es la criba del cuerpo de números, el algoritmo más rápido de factorización...
  function numberFieldSieve(n) {
    /*
    Documentación, según Wikipedia:



    */

    // Declaración de miembros: constantes, tipos, variables, etiquetas
    // y subfunciones de la función numberFieldSieve.

    // Función auxiliar para calcular el máximo común divisor
    function gcd(a, b) {
      if (b === 0n) {
        return a;
      }
      return gcd(b, a % b);
    }

    // Función auxiliar para calcular el módulo cuadrado
    function squareMod(n, m) {
      let tmpRest = n % m;
      return (tmpRest * tmpRest) % m;
    }

    // Función auxiliar para calcular el símbolo de Legendre
    function legendreSymbol(a, p) {
      const ls = squareMod(a, p);
      if (ls === 1n) {
        return 1n;
      } else if (ls === p - 1n) {
        return -1n;
      }
      return 0n;
    }

    // Cuerpo de la función numberFieldSieve
    const sqrtN = sqrt(n);

    // Verificar si n es un cuadrado perfecto
    if (sqrtN * sqrtN === n) {
      return sqrtN;
    }

    let a = 2n;
    while (true) {
      const b = legendreSymbol(a * a - n, n);
      if (b !== -1n) {
        const factor = gcd(a - b, n);
        if (factor !== 1n && factor !== n) {
          return factor;
        }
      }
      a++;
    }
  }

  function numberFieldSieveWithIterations(n, maxIterations = BigInt(100 + Math.trunc(2000 * n.toString().length))) {

    console.log(`El número de repeticiones es ${maxIterations}.`);

    // Función auxiliar para calcular el máximo común divisor
    function gcd(a, b) {
      if (b === 0n) {
        return a;
      }
      return gcd(b, a % b);
    }

    // Función auxiliar para calcular el módulo cuadrado
    function squareMod(n, m) {
      let tmpRest = n % m;
      return (tmpRest * tmpRest) % m;
    }

    // Función auxiliar para calcular el símbolo de Legendre
    function legendreSymbol(a, p) {
      const ls = squareMod(a, p);
      if (ls === 1n) {
        return 1n;
      } else if (ls === p - 1n) {
        return -1n;
      }
      return 0n;
    }

    // Cuerpo de la función numberFieldSieve
    const sqrtN = sqrt(n);

    // Verificar si n es un cuadrado perfecto
    if (sqrtN * sqrtN === n) {
      return sqrtN;
    }

    let a = 2n;
    let iterations = 0n;

    while (iterations < maxIterations) {
      const b = legendreSymbol(a * a - n, n);
      if (b !== -1n) {
        const factor = gcd(a - b, n);
        if (factor !== 1n && factor !== n) {
          return factor;
        }
      }
      a++;
      iterations++;
    }

    // Si no se encontró un factor primo después de maxIterations iteraciones,
    // se asume que el número es primo
    return n;
  }

  // Ejemplo de uso
  const number = BigInt('1234567890123456789012345678901234567890');
  const factor = quadraticSieve(number);
  console.log(`La criba cuadrática de ${factor} es ${number}.`);

  // Recuerda que esta implementación es solo un ejemplo y puede requerir ajustes adicionales según tus necesidades. En cuanto al copyright, ten en cuenta que el código proporcionado es solo una adaptación del algoritmo descrito en Wikipedia y no tiene restricciones de copyright. Sin embargo, ten en cuenta que siempre es recomendable verificar y respetar las licencias de cualquier código o algoritmo que utilices. ¡Espero que esto te sea útil

  // Prueba de carrera de tareas
  class Thread {

    static results = [];

    constructor(task = () => {
      return 'Ok';
    }) {
      this.addTask(task);
    }

    addTask(arrowFunction) {
      if (typeof arrowFunction !== 'function') {
        throw new Error('no es una función.');
      }

      this.id = this.generateId();
      this.code = arrowFunction;
      this.workerURL = this.createWorkerURL(`(${arrowFunction.toString()})();`);
      this.worker = new Worker(this.workerURL);
      this.startingTime = new Date();
      this.endingTime = null;
      this.status = null;
      this.result = null;
      this.worker.onmessage = (event) => {
        console.log('Punto de control 1: ', event);
        this.result = event.data;
        this.status = 'completed';
        this.endingTime = new Date();
      };
      this.worker.postMessage('start');
    }

    getResult() {
      return {id: this.id, result: Thread.results[this.id], status: this.status};
    }

    cancel() {
      this.worker.terminate();
      URL.revokeObjectURL(this.workerURL);
    }

    state(id) {
      return {id: this.id, status: this.status};
    }

    generateId() {
      return Math.random().toString(36).substr(2, 9);
    }

    createWorkerURL(code) {
      const blob = new Blob([code], {type: 'application/javascript'});
      return URL.createObjectURL(blob);
    }
  }

  // Arrancando las tareas

  const task1 = new Thread(() => {
    console.log('Tarea 1 ejecutándose...');
    return 'Resultado tarea 1';
  });

  const task2 = new Thread(() => {
    console.log('Tarea 2 ejecutándose...');
    return 'Resultado tarea 2';
  });

  const task3 = new Thread(() => {
    console.log('Tarea 3 ejecutándose...');
    return 'Resultado tarea 3';
  });


  // Cómo eliminar una tarea?

  const canceled = task1.cancel();
  console.log('Tarea cancelada:', canceled);

  // Y cómo conocer el estado

  const taskState = task2.state();
  console.log('Estado de la tarea:', taskState);

  // Felicidades, ahora sí podemos hacer una competencia de métodos de factorización en paralelo.
  // MULTITAREAS DENTRO DE HTML, NO ES SOLAMENTE UNA SIMULACION, SON VARIOS HILOS COMO TE LO CUENTO.
  // Solamente neesita que se almacenen los valores de las funciones.
  // By Pipo (que es Bultet) 2023

  // Bueno no son hilos primitivos a bajo nivel y microcódigo, pero son hilos al final, de alto nivel, tareas
  // más bien son tubos, pero lo importante es que se ejecutan en paralelo.


  // Factorización por búsqueda y captura.
  // Optimizar, para que también busque por la izquierda.
  function primalidadPorBusquedayCaptura(X, zeros = true) {
    // Copyright: ® 2023 Luis Bultet Ibles.

    function preSent(fact) {
      return {primality: fact == 1n && BigInt(fact) !== X, factor: BigInt(fact)};
    }

    if (X < 0n) {
      return preSent(-X);
    }

    // Raiz cuadrada from https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
    function sqrt(value) {

      if (value < 2n) {
        return value;
      }

      function newtonIteration(n, x0) {
        const x1 = ((n / x0) + x0) >> 1n;
        if (x0 === x1 || x0 === (x1 - 1n)) {
          return x0;
        }
        return newtonIteration(n, x1);
      }

      return newtonIteration(value, 1n);
    }

    // Subfunción: Cuántos de los últimos dígitos coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    // Subfunción: Extraer los n últimos dígitos de X
    function nUltimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Último dígito de X
    const ultimoDigito = nUltimosDigitosDeX(1, X);

    // Lista de candidatos de factores
    let candidatos = [];

    // Etapa 1: Agregar los candidatos de factores
    switch (ultimoDigito) {
      case '0':
        return preSent(2n);
      case '1':
        candidatos.push(['1', '1'], ['3', '7'], ['9', '9']);
        break;
      case '2':
        return preSent(2n);
      case '3':
        candidatos.push(['1', '3'], ['7', '9']);
        break;
      case '4':
        return preSent(2n);
      case '5':
        return preSent(5n);
      case '6':
        return 2n;
      case '7':
        candidatos.push(['1', '7'], ['3', '9']);
        break;
      case '8':
        return preSent(2n);
      case '9':
        candidatos.push(['1', '9'], ['3', '3'], ['7', '7']);
        break;
    }

    // Etapa 2: Calcular la raíz cuadrada de X
    const raizCuadrada = sqrt(X);

    // Debug, ignore it.
    function rapport(digit) {
      console.log((100 * digit / X.toString().length).toFixed(3), '% , analizando dígito ', digit, ' uso de memoria: ', candidatos.length);
    }

    // Debug, ignore it.
    rapport(1);

    // Generaciones
    let generaciones;

    // Etapa 3: Buscar divisor primo
    for (let digitosNecesarios = 2; digitosNecesarios <= raizCuadrada.toString().length; digitosNecesarios++) {

      generaciones = candidatos.length;

      if (generaciones === 0) { // se eliminaron todos los candidatos.
        break;
      }

      // Debug, ignore it.
      rapport(digitosNecesarios); // actualiza la barra de progreso

      // Etapa 3.2: Agregar los 10 dígitos a la derecha y a la izquierda de los factores
      while (generaciones > 0) {
        generaciones--;
        let candidato = candidatos.shift();
        for (let j = zeros ? 0 : 1; j < 9; j++) {
          for (let k = zeros ? 0 : 1; k < 9; k++) {
            let f1 = String(j) + candidato[0];
            let f2 = String(k) + candidato[1];

            [f1, f2] = [menor(f1, f2), mayor(f1, f2)];

            // Ya existe, no lo agrego
            if (candidatos.some((x) => x[0] === f1 && x[1] === f2)) {
              continue;
            }

            // La suma de las longitudes se pasan del objetivo, se supone que producto se pase o se encuentren soluciones menores
            if (f1.length + f2.length > X.toString().length || BigInt(f1) > raizCuadrada || BigInt(f2) > raizCuadrada) {
              continue;
            }

            // Si ambos de ellos comienzan con "0", no volver a chequearlos
            if (f1[0] !== '0' || f2[0] !== '0') {

              // Calcular el producto de los valores absolutos de los candidatos.
              let subProd = BigInt(f1) * BigInt(f2);

              // El producto se pasa
              if (subProd > X) {
                continue;
              } else if (subProd < X) { // El producto es menor
                // Comprobar si alguno de los candidatos divide a X
                if (X % BigInt(f1) === 0n && (BigInt(f1) !== 1n && BigInt(f1) !== X)) {
                  return preSent(f1);
                } else if (X % BigInt(f2) === 0n && (BigInt(f2) !== 1n && BigInt(f2) !== X)) {
                  return preSent(f2);
                }
              } else if (subProd === X) { // El producto es igual
                return preSent(menor(f1, f2));
              }

              // Coinciden los dígitos necesarios al final
              if (coincidenciasAlFinal(X.toString(), subProd.toString()) < digitosNecesarios) {
                continue;
              }
            }

            candidatos.push([f1, f2]);
          }
        }
      }
    }

    // Etapa 5: Devolver el número X si no se encontraron factores
    return preSent(X);
  }

  /*
    CREADO POR JLCY 17-1-2016
    APLICANDO EL LEMA DE BEZOUT SE CONSIGUE LLEGAR AL MCD DE "a" Y "p"
    COMO UNA COMBINACION LINEAL DE "a" y "p" CON EL ALGORITMO DE EUCLIDES.
    YA CON ESTO SI EL MCD ES 1 , "a" y "p" son primos relativos y existe el inverso de "a" modulo "m"
    ESTA SOLUCION ES MAS OPTIMA YA QUE NO PARA SOBRE TODOS LOS POSIBLES INVERSOS
    */
  function obtenerUnInversoMultiplicativo(a, m) {
    let c1 = 1n;
    let c2 = -(m / a); // coeficiente de a y b respectivamente
    let t1 = 0n;
    let t2 = 1n; // coeficientes penúltima corrida
    let r = m % a; // residuo, asignamos 1 como condición de entrada
    let x = a;
    let y = r;
    let c;
    while (r !== 0n) {
      c = x / y; // cociente
      r = x % y; // residuo
      // guardamos valores temporales de los coeficientes
      // multiplicamos los coeficientes por -1*cociente de la division
      c1 *= -c;
      c2 *= -c;
      //sumamos la corrida anterior
      c1 += t1;
      c2 += t2;
      //actualizamos corrida anterior
      t1 = -(c1 - t1) / c;
      t2 = -(c2 - t2) / c;
      x = y;
      y = r;
    }
    //residuo anterior es 1, son primos relativos y el inverso existe
    return (x === 1n) ? t2 : null; //residuo anterior es 1, son primos relativos y el inverso existe; de otro modo null.
  }


  // Calculador de inversos modulares (CIM) (from Wikipedia)
  // Hallar todos los b, tal que (a * b)(mod m) = 1 .
  function obtenerTodosLosInversosMultiplicativos(a, m) {
    let resultado = [];

    let b; // Valores para los que se cumple que (a * b)(mod m)
    let x; // Candidatos

    for (b = 0n; b < m; b++) {
      x = (a * b) % m;
      if (x === 1n) {
        resultado.push(b);
      }
    }

    return resultado;
  }

  // El inverso multiplicativo de a módulo m se puede obtener mediante el Algoritmo de Euclides.
  // En particular, invocando el algoritmo extendido de Euclides con a y m como argumentos
  // se obtiene una tripla (x,y,mcd(a,m)) tal que:
  // xa + ym = mcd(a, m)
  // si mcd(a, m) = 1, entonces
  // xa congruente con 1 (mod m)
  // de donde x es el inverso modular de a módulo m.
  // Si el MCD(a, m)≠ 1 entonces no existe el modular inverso.
  // Este algoritmo se ejecuta en un tiempo O(log(m)²) (asumiendo que |a|<m).
  function obtenerUnInversoMultiplicativoPorAlgoritmoEuclides(a, m) {
    let result;

    let bezout_mcd = mcd(a, m);
    if (bezout_mcd !== 1n) {
      result = null; // no existe el modular inverso.
    } else {
      result = extendedEuclides(a, m)[0]; // a
    }

    return result;

  }

  // Funciones aritméticas elementales y avanzadas, para enteros BigInt.
  // En estas expresiones / se refiere a la división entera y % al residuo
  // o resto de la división.

  // Función para calcular el máximo común divisor
  function maximoComunDivisor(a, b) { // ok
    let result;
    let [minFactor, maxFactor] = [menor(a, b), mayor(a, b)];
    // this trivial checks avoids div. by zero.
    result = maxFactor;
    while (minFactor !== 0n) {
      maxFactor = result;
      result = minFactor;
      minFactor = maxFactor % minFactor;
    }
    return result;
  }

  // Función para calcular el minimoComunMultiplo
  function minimoComunMultiplo(a, b) { // ok
    return a * b / mcd(a, b);
  }

  // Función para calcular el menor múltiplo de a, mayor que b.
  function menorMultiploMayor(a, b) { // ok
    return a * ((b + a - 1n) / a);
  }

  // Función para calcular el mayor múltiplo de a, menor que b.
  function mayorMultiploMenor(a, b) { // ok
    return a * ((b + a - 1n) / a - 1n);
  }

  // ok
  function euclideanAlgorithmExtended(a, b) {
    if (b === 0n) {
      return [a, 1n, 0n];
    }
    const [gcd, x1, y1] = euclideanAlgorithmExtended(b, a % b);
    const x = y1;
    const y = x1 - (a / b) * BigInt(y1);
    return [gcd, x, y];
  }


  // Función para determinar el mayor divisor de a menor que b utilizando el pequeño teorema de Fermat
  function mayorDivisorDeA(a, b) {
    if (b < 2n) {
      return null;
    }

    if (a === 0n || b === 2n) {
      return b - 1n;
    }

    if (a === 1n) {
      return 1n;
    }

    if (a < b) {
      return a;
    }

    if (a % b) {
      let c = a / b;
      if (c < b) return c;
    }

    // Buscamos el menor exponente n para el cual a^n ≡ 1 (mod b)
    let n = 1n;
    while (modpow(a, n, b) !== 1n) {
      n++;
    }

    // Otra vía
    // // El mayor divisor de a menor que b es a^(n-1)
    // return modpow(a, n - 1n, b);
    //
    // // Encuentra el mayor primo menor que "n"
    // function findLargestPrime(n) {
    //   let largestPrime = n - 1n;
    //   while (!isPrime(largestPrime, 10)) {
    //     largestPrime--;
    //   }
    //   return largestPrime;
    // }
    //
    // if (a <= 0n || b <= 0n) {
    //   return null;
    // }
    //
    // const p = findLargestPrime(b);
    // const inverse = multiplicativeInverse(a % p, p);
    //
    // if (inverse === null) {
    //   return null;
    // }
    //
    // return (a * inverse) % b;
  }

  // Función para calcular el mayor divisor de a, menor que b.
  function mayorDivisorMenor(a, b) { // arreglar

    // arreglar las condiciones
    if (a === 0n || (b !== 0n && a % b === 0n) || (b !== 0n && a % (b - 1n) === 0n)) {
      return b - 1n;
    }

    // funciones auxiliares

    // Función para calcular el mayor número menor que a, divisor de b utilizando el algoritmo extendido de Euclides.
    function euclideanAlgorithmExtended(a, b) {
      if (b === 0n) {
        return [a, 1n, 0n];
      }
      const [gcd, x1, y1] = euclideanAlgorithmExtended(b, a % b);
      const x = y1;
      const y = x1 - (a / b) * y1;
      return [gcd, x, y]; // ax + by = gcd
    }

    // Calcula el inverso multiplicativo de "a" módulo "n".
    function multiplicativeInverse(a, n) {
      const [gcd, x, y] = euclideanAlgorithmExtended(a, n);
      if (gcd !== 1n) {
        return null;
      }
      return (x % n + n) % n;
    }

    // Calcula a^b modulo p
    function powerMod(a, b, p) {
      let result = 1n;
      a = a % p;
      while (b > 0n) {
        if (b % 2n === 1n) {
          result = (result * a) % p;
        }
        b = b / 2n;
        a = (a * a) % p;
      }
      return result;
    }


    /*
        Función para calcular el mayor número menor que a, divisor de b utilizando el pequeño teorema de Fermat.
        El pequeño teorema de Fermat establece que si p es un número primo y a, es un número entero no divisible por p,
        entonces a^(p-1) ≡ 1 mod p.

        Por lo tanto, podemos usar este teorema para calcular el inverso multiplicativo de a módulo p de la siguiente manera:

        a^(p-2) ≡ a^(-1) mod p.

        En este caso, queremos encontrar el mayor número menor que a, divisor de b.

        Entonces, podemos buscar a^n mod b = 1 para el menor n posible.

        A punto de encontrarlo, a^n-1 será el mayor número menor que a, divisor de b.

        La implementación actual de esta función es por fuerza bruta, utilice el algoritmo de extendido de Euclides para
        lograr una complejidad O(log(p)) por debajo la del método mostradoa O(log(p)³), que además retorna null o 1, si no se
        encuentra el número, para lo cual puede utilizar la identidad de Bezout.
    */


  }


  function AnalizarElDesparpajoFeChatGPTParaMayorDivisorMenor(a, b) {
    if (a === 0n || (b !== 0n && a % b === 0n) || (b !== 0n && a % (b - 1n) === 0n)) {
      return b - 1n;
    }

    // Función para calcular el mayor número menor que a, divisor de b utilizando el algoritmo extendido de Euclides.
    function euclideanAlgorithmExtended(a, b) {
      if (b === 0n) {
        return [a, 1n, 0n];
      }
      const [gcd, x1, y1] = euclideanAlgorithmExtended(b, a % b);
      const x = y1;
      const y = x1 - (a / b) * y1;
      return [gcd, x, y];
    }

    // Calcula el inverso multiplicativo de "a" módulo "n".
    function multiplicativeInverse(a, n) {
      const [gcd, x, y] = euclideanAlgorithmExtended(a, n);
      if (gcd !== 1n) {
        return null;
      }
      return (x % n + n) % n;
    }

    let n = 2n;
    while (n <= a && n <= b) {
      // Si "n" es un divisor de "b" pero no de "a", encontramos el número buscado.
      if (b % n === 0n && a % n !== 0n) {
        const inverse = multiplicativeInverse(n, a);
        if (inverse !== null) {
          // El mayor número menor que "a", divisor de "b" es n^inverse.
          return n ** inverse;
        }
      }
      n += 1n;
    }

    return null; // Si no se encuentra el número buscado.
  }


  // Función para calcular el menor divisor de a, mayor que b.
  function menorDivisorMayor(a, b) { // arreglar
    if (b >= a) {
      return null; // un # más grande no puede dividir a otro más pequeño.
    }
    // tarea
  }

  function test() {
    function repetir(digito, veces) {
      let result = '';
      for (let i = 0; i < veces; i++) {
        result = result + digito;
      }
      return result;
    }

    // Algoritmo para encontrar un factor arbitrario
    function primalidadPorFactorArbitrario(x) {
      if (!x || x < 2n) {
        return {primalidad: false, factor: x};
      } else if (x === 2n || x === 3n || x === 5n) {
        return {primalidad: true, factor: x};
      } else if (x % 2n === 0n) {
        return {primalidad: false, factor: 2n};
      } else if (x % 3n === 0n) {
        return {primalidad: false, factor: 3n};
      } else if (x % 5n === 0n) {
        return {primalidad: false, factor: 5n};
      } // Pueden agregarse los criterios de divisibilidad...

      // Ningún número tiene divisores primos por encima de su raiz cuadrada
      let r2 = root(x, 2n);
      if (r2 * r2 === x) { // es un cuadrado perfecto
        return primalidadPorFactorArbitrario(r2);
      }

      // Pero además, si es compuesto y no es una raíz cuadrada, ni una raíz cúbica;
      // debe tener al menos un factor común, con alguno entre su raíz cúbica y su raíz cuadrada.
      let r3 = root(x, 3n);
      if (r3 * r3 * r3 === x) { // es un cubo perfecto
        return primalidadPorFactorArbitrario(r3);
      }

      // Este algoritmo trata de encontrar ese número, y luego calcular su máximo común denominador
      // que debe ser es un divisor del número, si existiese.

      // implementar la búsqueda del menor divisor de un valor (x), mayor que un otro valor dado (en este caso 1).
      let resultado = mayorDivisorDeA(x, r2);

      return {
        primalidad: resultado === 1n || resultado === x,
        factor: resultado,
      };
    }

    alert('Enter para comenzar el test de depuración.');
    for (let i = 0n; i < 1111111n; i++) {
      let no = BigInt(repetir('1', i));
      // console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${encontrarUnFactorPrimo(no)}<--.`);
      // console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${encontrarUnFactorPrimo(no)}<--.`);
      // console.warn(`Un factor primo de 2^${no} - 1 = ${pow(2n, no) - 1n}, es -->${encontrarUnFactorPrimo(pow(2n, no) - 1n)}<--.`);
      console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${primalidadPorTentativa(no).factor}<-- (Primalidad por tentativa).`);
      console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${primalidadPorBusquedayCaptura(no).factor}<-- (Primalidad por búsqueda y captura).`);
      // console.warn(`Un factor primo de ${i}, es -->${primalidadPorTentativa(i).factor}<-- (brute force), -->${pollardRho(i).factor}<-- (Pollard),.`);
      if (primalidadPorTentativa(i).factor !== primalidadPorBusquedayCaptura(i).factor) alert(`Falla en ${i}.`);
    }
  }

  function bueyFactor(n) {

    function powerMod(a, b, p) {
      // Calcula (a^b) % p utilizando el algoritmo de exponenciación modular
      let result = 1n;
      a = a % p;
      while (b > 0n) {
        if (b % 2n === 1n) {
          result = (result * a) % p;
        }
        b = b / 2n;
        a = (a * a) % p;
      }
      return result;
    }

    function euclideanAlgorithm(a, b) {
      // Encuentra el máximo común divisor de a y b utilizando el algoritmo de Euclides
      while (b !== 0n) {
        const temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    let a = 2n; // Empezamos con a = 2
    let b = 2n;
    let d;

    while (true) {
      a = powerMod(a, 2n, n) + 1n;
      b = powerMod(b, 2n, n) + 1n;
      b = powerMod(b, 2n, n) + 1n;

      d = euclideanAlgorithmExtended(a > b ? a - b : b - a, n)[0];

      if (d !== 1n && d !== n) {
        return d; // Se encontró un factor
      }
    }
  }


  // Función para encontrar un factor primo de x utilizando el teorema de Fermat y el MCD
  function findPrimeFactor(p, base = 2n) {

// Función para calcular el valor a^b % p de forma eficiente utilizando el algoritmo de exponenciación rápida
    function modpow(a, b, p) {
      let result = 1n;
      while (b > 0n) {
        if (b & 1n) { // si b es impar
          result = (result * a) % p;
        }
        a = (a * a) % p;
        b >>= 1n; // dividir b por 2
      }
      return result;
    }

    console.log(BigInt(p.toString().length));
    let factor, i;
    for (let i = 0n; i < BigInt(p.toString().length); i++) {
      console.log(i);
      // El original
      factor = mcd(p, p - modpow(base, p + i, p) - 1n);
      if (factor !== 1n && factor !== p) {
        return factor;
      }
      // Los bastardos
      factor = mcd(p, p - modpow(base, p + i, p) + 1n);
      if (factor !== 1n && factor !== p) {
        console.log('bastardo 1');
        return factor;
      }
      factor = mcd(p, p - modpow(base, p - i, p) - 1n);
      if (factor !== 1n && factor !== p) {
        console.log('bastardo 2');
        return factor;
      }
      factor = mcd(p, p - modpow(base, p - i, p) + 1n);
      if (factor !== 1n && factor !== p) {
        console.log('bastardo 3');
        return factor;
      }

    }

    return null; // si no se encuentra ningún factor primo
  }

  function test2() {
    function identicalOnTheRange(x) {
      return 1 / 2 + Math.atan(Math.tan((Math.PI * x) - (Math.PI / 2))) / Math.PI;
    }

    for (let i = -10; i < 10; i += 0.025) {
      console.log(`f(${i.toFixed(3)}) = ${identicalOnTheRange(i)}`);
    }
  }

  function test3() {
    function isPrime(n) {
      if (n <= 1) {
        return false;
      }
      if (n <= 3) {
        return true;
      }
      if (n % 2 === 0 || n % 3 === 0) {
        return false;
      }
      let i = 5;
      while (i * i <= n) {
        if (n % i === 0 || n % (i + 2) === 0) {
          return false;
        }
        i += 6;
      }
      return true;
    }

    function mcd(a, b) {
      let result;
      let [minFactor, maxFactor] = [menor(a, b), mayor(a, b)];
      // this trivial checks avoids div. by zero.
      result = maxFactor;
      while (minFactor !== 0) {
        maxFactor = result;
        result = minFactor;
        minFactor = maxFactor % minFactor;
      }
      return result;
    }

    function classicLucasLehmerTest(p) {
      let result;
      if (p === 2n) {
        result = true;
      } else {
        let s = 4n;
        for (let i = 3n; i <= p; i++) {
          s = (s * s - 2n) % ((1n << p) - 1n); // (s * s - 2n) % ((2 ** p) - 1n);
        }
        return s === 0n;
      }
      return result;
    }

    // Contiene la solución mejorada
    function modernLucasLehmerTest(p) {
      // Función para obtener a mod (c**d)
      function modBigInt(a, c, d) {
        if (d === 0n) {
          return 1n;
        }

        if (c === 0n) {
          return 0n;
        }

        // Reducir a mediante el módulo c^d
        a = a % (c ** d);
        let result = 1n;

        while (d > 0n) {
          // Si d es par, multiplicar resultado por a
          if (d % 2n !== 0n) {
            result = (result * a) % (c ** d);
          }

          // Reducir a mediante el módulo c^d
          a = (a * a) % (c ** d);
          d = d >> 1n;  // Corrección: usar desplazamiento a la derecha en lugar de división
        }

        return result;
      }

      let result;
      if (p === 2n) {
        result = true;
      } else {
        let s = 4n;
        const m = 2n ** p - 1n;

        for (let i = 0n; i < p - 2n; i++) {
          s = modBigInt((s ** 2n - 2n), m, p);
        }

        result = (s === 0n);
      }
      return result;
    }


    result = '';
    let no = 0;
    for (let i = 2n; i < 9999999999999n; i++) {
      // if (!isPrime(i)) continue;
      // console.log(`f(${i}) = ${eulerPi(i)}`);
      let mR = classicLucasLehmerTest(i);
      if (mR) {
        no++;
        console.log(`2^${i} - 1 ${mR ? `is` : `is not`} prime number ${no} según el test.`);
        console.log(' ');
      }
      // result = result + `${primeCount(i)}, `;
    }
    return result;
  }

  /*

  a - (a % b) siempre es divisible por b

  de x si encuentro x = a - (a % b), b es factor para un a grande.

  pero

  a % b = a - b * int(a/b)

  a % b = a - b * ((a/b) - fraccir(a/b))

  a % b = a - b * ((a/b) - fraccir(a/b))

        = a - b (a/b) - (1/2 + atn(tan(πx - π/2)) / π)

        luego

    x = a + (1/2 + atn(tan(πx - π/2)) / π)

    si defino:

     parte fraccionaria(x)  = 1/2 + atn(tan(πx - π/2)) / π,
     parte entera(x) = x - frac(x) = x - 1/2 + atn(tan(πx - π/2)) / π,
     resto de la división(x, y) = y * frac(x/y) = y * (1/2 + atn(tan(πx - π/2)) / π)
     función primalidad(x) = Γ²(x - 2) mod x = x * (1/2 + atn(tan(π(Γ²(x - 2)) - π/2)) / π)

     ///////////


     Si y divide a x

     y * (1/2 + atn(tan(πx/y - π/2)) / π) = 0

    tan(π y / 2) = tan(πx/y - π/2)

  */


  function test2() {
    function identicalOnTheRange(x) {
      return 1 / 2 + Math.atan(Math.tan((Math.PI * x) - (Math.PI / 2))) / Math.PI;
    }

    // Funciones de enteros convertidas a analíticas
    let π = 3.141592653589793238462643383279528841971693993751582974944592378164628;

    // Para valores impares de x

    // Solamente funciona cuando x no es entero...
    function parteFraccionaria(x) {
      return 1 / 2 + Math.atan(Math.tan((π * x - π / 2))) / π; // ok
    }

    function parteEntera(x) {
      return x - parteFraccionaria(x);
    }

    function residuoDivision(x, y) {
      return x - y * parteEntera(x / y);
    }

    // despeje: f(x) = 2x - 2 atan(tan(pi x / ( 2 y ) - pi / 2)) / pi

    // Stable diffussion:
    // Yo: Hola, Soy yo otra vez; necesito que vuelvas a despejar: y, en función de x, la siguiente ecuación:
    // 1 / 2 + atan(tan((π * (x / y) - π / 2))) / π = 0


    // parte entera(x) = x - frac(x) = x - 1/2 + atn(tan(πx - π/2)) / π,
    // resto de la división(x, y) = y * frac(x/y) = y * (1/2 + atn(tan(πx - π/2)) / π)
    // cociente de la división(x, y) = x - y*(y * frac(x/y) = y * (1/2 + atn(tan(πx - π/2)) / π))
    // función primalidad(x) = Γ²(x - 2) mod x = x * (1/2 + atn(tan(π(Γ²(x - 2)) - π/2)) / π)

    for (let a = 0; a < 20; a++) {
      for (let b = 1; b <= 4; b++) {

        console.log(`parte fraccionaria de (${a.toFixed(3)}/${b.toFixed(3)} = ${a / b}) = ${parteFraccionaria(a / b).toFixed(3)}`);
        // console.log(`parte entera de (${a.toFixed(3)}/${b.toFixed(3)} = ${Math.trunc(a / b).toFixed(3)}) = ${parteEntera(a / b).toFixed(3)}`);
        // console.log(`resto de la división de (${a.toFixed(3)} por ${b.toFixed(3)} = ${(a % b).toFixed(3)}) = ${residuoDivision(a, b).toFixed(3)}`);

      }
    }

  }

  // Las últimas trovas están en: "algoritmo de factorizacion.txt"
  // https://stablediffusion.fr/chatgpt3

  function li(x) {
    // Función de Li aproximada
    return x / logaritmo(x);
  }

  // Más o menos...
  function primeCount(x) {

    function nextPrime(n) {
      if (n <= 2n) {
        return 2n;
      }

      let prime = n % 2n === 0n ? n + 1n : n + 2n;

      while (!isPrime(prime)) {
        prime += 2n;
      }

      return prime;
    }

    function isPrime(n) {
      if (n <= 1n) {
        return false;
      }
      if (n <= 3n) {
        return true;
      }
      if (n % 2n === 0n || n % 3n === 0n) {
        return false;
      }
      let i = 5n;
      while (i * i <= n) {
        if (n % i === 0n || n % (i + 2n) === 0n) {
          return false;
        }
        i += 6n;
      }
      return true;
    }

    function li(x) {
      // Función de Li aproximada
      const logx = Math.log(x);
      const lix = x / Math.log(x);

      return BigInt(Math.floor(lix));
    }

    if (x <= 2n) {
      return 0n;
    }

    const logx = Math.log(Number(x));
    const sqrtx = Math.sqrt(Number(x));
    const lix = li(x);

    let sum = 0n;

    for (let p = 2n; p <= x; p = nextPrime) {
      sum += 1n;
    }

    const piLi = lix - sum;

    let error = NaN;

    if (sum > piLi) {
      error = '+';
    } else if (sum < piLi) {
      error = '-';
    } else {
      error = '0';
    }

    const result = {
      indice: sum,
      error: error,
    };

    return result;
  }

  // arreglar con valores realles precisión:
  function riemmann() {
    // Función para calcular la diferencia entre Li(x) y π(x) utilizando la fórmula de la función de Riemann (arreglar)
    function calcularDiferencia(x) {

      // Función para calcular los ceros no triviales de la función zeta de Riemann (solo una aproximación)
      function calcularCeroNoTrivial(n) {
        if (n < 6) {
          // Aproximación de los ceros no triviales para los primeros valores de n
          const ceros = [14.134725141734693, 21.022039638771554, 25.010857580145688, 30.42487612585944, 32.93506158773918, 37.58617815882568];

          // Retornar el n-ésimo cero no trivial, si está disponible. De lo contrario, retornar NaN.
          return ceros[Number(n) - 1];
        } else {

          const pi = 3.141592653589793238462643383279502884197169399375;
          const realPart = pi / (Number(n) ** 2);

          // Retornar la parte real del cero no trivial
          if (n % BigInt(2) === BigInt(0)) {
            return realPart;
          } else {
            return realPart + pi;
          }
        }
      }

      // Variable para almacenar la diferencia
      let diferencia = 0;

      // Definir la precisión deseada (cantidad de términos de la fórmula a considerar)
      const precision = BigInt(100);

      // Calcular la diferencia utilizando la fórmula de la función de Riemann
      for (let n = BigInt(1); n <= precision; n++) {
        const ceroNoTrivial = calcularCeroNoTrivial(n);
        const coseno = Math.cos(parseFloat(ceroNoTrivial) * Math.log(parseFloat(x)));
        const termino = coseno / (Number(n) * (ceroNoTrivial ** 2));

        // Sumar el término al resultado
        diferencia += Number(termino);
      }

      // Multiplicar la diferencia por x para ajustar la escala
      diferencia = Number(x) * diferencia;

      // Retornar la diferencia calculada
      return diferencia;

    }


    // Prueba de la función calcularDiferencia para x = 100
    const x = 100;
    const diferencia = calcularDiferencia(x);
    console.log('Diferencia entre Li(x) y π(x) para x =', x, ':', diferencia);
  }


  function test4() {


    function upToDate(x) {
      let Men = [2n, 3n, 5n, 7n, 13n, 17n, 19n, 31n, 61n, 89n, 107n, 127n, 521n, 607n, 1279n, 2203n,
        2281n, 3217n, 4253n, 4423n, 9689n, 9941n, 11213n, 19937n, 21701n, 23209n, 44497n,
        86243n, 110503n, 132049n, 216091n, 756839n, 859433n, 1257787n, 1398269n, 2976221n,
        3021377n, 6972593n, 13466917n, 20996011n, 24036583n, 25964951n, 30402457n, 32582657n,
        37156667n, 42643801n, 43112609n, 57885161n, 74207281n, 77232917n];

      function lucasLehmerMCD(a, p, q) {
        function gcd(a, b) {
          if (b === 0n) {
            return a;
          }
          return gcd(b, a % b);
        }

        const m = p - 1n;
        const n = q - 1n;
        const mcd = gcd(m, n);
        const result = a ** mcd - 1n;
        return result;
      }

      for (let i = 0; i < Men.length; i++) {
        result = x % Men[i];
        if (result === 0n) {
          return Men[i]; // Devuelve el factor primo
        }
        // .. seguir
        result = mcd(modpow(Men[i], x - 1n, x), x);
        if (result > 1n && result < x && x % result === 0n) {
          return result; // Devuelve el factor primo
        }
      }

      return x; // Si no se encuentra un factor, devuelve 1
    }

    for (let i = -10; i < 10; i += 0.025) {
      console.log(`f(${i.toFixed(3)}) = ${upToDate(i)}`);
    }
  }

  function encontrarRaices(n) {

    // Raiz cuadrada
    // from https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
    function sqrt(value) {
      if (value < 0n) {
        throw 'square root of negative numbers is not supported';
      }

      if (value < 2n) {
        return value;
      }

      function newtonIteration(n, x0) {
        const x1 = ((n / x0) + x0) >> 1n;
        if (x0 === x1 || x0 === (x1 - 1n)) {
          return x0;
        }
        return newtonIteration(n, x1);
      }

      return newtonIteration(value, 1n);
    }

    // Convierte n a un número entero
    n = BigInt(n);

    // Coeficientes de la ecuación cuadrática
    let a = 1n;
    let b = n;
    let c = -(n * n - 2n);

    // Calcula las raíces usando la fórmula cuadrática
    let discriminante = b * b - 4n * a * c;

    if (discriminante < 0n) {
      // Si el discriminante es negativo, no hay raíces reales
      return null;
    } else {
      // Calcula las dos raíces
      let raiz1 = (-b + sqrt(discriminante)) / (2n * a);
      let raiz2 = (-b - sqrt(discriminante)) / (2n * a);

      // Devuelve las raíces como un arreglo
      return [2n * n * raiz1 + 1n, 2n * n * raiz2 + 1n];
    }
  }

  function obtenerDigitosMersenne() {

    // Resto de la division base^exp mod m
    function modpow(a, b, p) {
      // Calcula (a^b) % p utilizando el algoritmo de exponenciación modular
      let result = 1n;
      a = a % p;
      while (b > 0n) {
        if (b % 2n === 1n) {
          result = (result * a) % p;
        }
        b = b / 2n;
        a = (a * a) % p;
      }
      return result;
    }


    // 82.589.933
    // console.log(modpow(2n, Math.trunc(82589933 - )))
  }


</script>
<button onclick="calcular(BigInt(leerAreaDeTexto()));">
    Factorizar
</button>
</body>
</html>