<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<textarea id="textarea1"></textarea>
<script language="JavaScript">

  // Factorización "hacker" de números naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el lunes 23 de octubre de 2023; 11:20 AM
  // En fase de depuración y puesta a punto.
  //
  // Todos los derechos reservados, por favor contáctenos personalmente para cualquier uso comercial.
  // Uso académico autorizado.
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  // Try to solve ($200 000.00 premium) RSA-2048
  // textArea1.value = '25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357';

  // By the way, begin with this (should return: 465675465116607065549 x 4892055594575155744537):
  textArea1.value = '2278110264380085376170666039415109857655813';

  function leerAreaDeTexto() {
    return textArea1.value;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.value = String(s);
  }

  // Funciones matemáticas comunes

  // Raiz cuadrada
  // from https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
  function sqrt(value) {
    if (value < 0n) {
      throw 'square root of negative numbers is not supported';
    }

    if (value < 2n) {
      return value;
    }

    function newtonIteration(n, x0) {
      const x1 = ((n / x0) + x0) >> 1n;
      if (x0 === x1 || x0 === (x1 - 1n)) {
        return x0;
      }
      return newtonIteration(n, x1);
    }

    return newtonIteration(value, 1n);
  }

  // power, solo enteros grandes
  function pow(base, exponent) {
    let result;
    if (base === 0n) {
      return 0n;
    } else if (base === 1n) {
      result = 1n;
    } else if (exponent === 2n) {
      result = base * base;
    } else if (exponent === 1n) {
      result = base;
    } else if (exponent === 0n) {
      result = 1n;
    } else if (exponent % 2n === 0n) {
      result = pow(pow(base, exponent / 2n), 2n);
    } else { // Legendre algorithm
      result = base * pow(base, exponent - 1n);
    }
    return result;
  }

  // Resto de la division base^exp mod m
  function modpow(base, exp, m) {
    let result = 1n;
    while (exp > 0n) {
      if (exp % 2n !== 0n) {
        result = (result * base) % m;
      }
      exp = exp / 2n;
      base = (base * base) % m;
    }
    return result;
  }

  function menor(x, y) {
    if (x < y) return x; else return y;
  }

  function mayor(x, y) {
    if (x > y) return x; else return y;
  }

  function mcd(a, b) {


    let result;
    let [minFactor, maxFactor] = [menor(a, b), mayor(a, b)];
    // this trivial checks avoids div. by zero.
    result = maxFactor;
    while (minFactor !== 0n) {
      maxFactor = result;
      result = minFactor;
      minFactor = maxFactor % minFactor;
    }
    return result;
  }

  // Pequeño teorema de Fermat
  function factorTentativo(x, deep = 1000n) {
    let result = x;
    if (x % 2n === 0n) {
      result = 2;
    } else {
      let pruebaFermat = modpow(2n, x - 1n, x);
      if (pruebaFermat !== 1n) {
        // No es primo, pues no pasa la prueba de Fermat, deja un resto de ', pruebaFermat);
      } else {
        result = x;
      }
    }
    // Ya que p es impar, por diferencia de cuadrados: [2^[(p-1)/2] + 1] * [2^[(p-1)/2] - 1] es divisible por p
    let divisor;
    for (let i = 0n; i < deep; i++) {
      divisor = mcd(x, modpow(2n, x + i, x) - 1n);
      if (divisor !== 1n && divisor !== x && x % divisor === 0n) return menor(divisor, x / divisor);
      divisor = mcd(x, modpow(2n, x - i, x) - 1n);
      if (divisor !== 1n && divisor !== x && x % divisor === 0n) return menor(divisor, x / divisor);
    }
    return result;
  }

  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarMenorFactorPrimo(decimal) {
    decimal = String(decimal).trim();

    let valorEnteroGrande = BigInt(decimal);

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (valorEnteroGrande < 4n) {
      return resultado;
    }

    let raizCuadrada = sqrt(valorEnteroGrande);
    if (raizCuadrada >= 2 && valorEnteroGrande % raizCuadrada === 0n) {
      return encontrarMenorFactorPrimo(raizCuadrada);
    }

    let factorFermat = factorTentativo(valorEnteroGrande);
    if (factorFermat >= 2 && factorFermat !==valorEnteroGrande && valorEnteroGrande % factorFermat === 0n) {
      return encontrarMenorFactorPrimo(factorFermat);
    }
    console.log('Pasa');

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => {
          return element[0] === par[0] && element[1] === par[1];
        },
      );
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos

    let producto = 1;

    function agregarCandidatosDeFactores(factor1, factor2) {
      // si acaso un resultado positivo.
      let result = false;
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      // si no existe el par en la lista agrégalo (si no exceden la raíz cuadrada)
      let subProd = BigInt(factor1) * BigInt(factor2);
      if (subProd === valorEnteroGrande) {
        result = true;
      } else if (subProd < valorEnteroGrande && !existsCandidates(par)) {
        // además, con al menos dos dígitos de error para el acarreo y se concatenan con su formato actual
        // el error permitido es 2 para productos de 1 carácter y 0 para productos que tengan la misma longitud que el parámetro
        // o sea
        let errorPermitido = Math.round(2 * (decimal.toString().length - subProd.toString().length) / decimal.toString().length);
        if (coincidenciasAlFinal(decimal, producto.toString()) >= Math.max(factor1.length, factor2.length) - errorPermitido) {
          candidatos.push([factor1, factor2]);
        }
      }
      return result;
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(1, decimal);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores('1', '1');
        agregarCandidatosDeFactores('3', '7');
        agregarCandidatosDeFactores('9', '9');
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores('1', '3');
        agregarCandidatosDeFactores('7', '9');
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores('1', '7');
        agregarCandidatosDeFactores('3', '9');
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores('1', '9');
        agregarCandidatosDeFactores('3', '3');
        agregarCandidatosDeFactores('7', '7');
        break;
      }
    }

    function menorFactor(b) {
      let a = valorEnteroGrande / BigInt(b);

      // Es recursiva, primero sácale presión a la caldera
      candidatos = [];

      x = encontrarMenorFactorPrimo(a);
      y = encontrarMenorFactorPrimo(b);
      if (x < y) {
        return x;
      }
      return y;
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    // Después de 200 iteraciones se eliminan los candidatos de menos dos dígitos,
    // de 300 las de menos de tres, así sucesivamente;
    let iteraciones = 0;

    if (candidatos.length > 0) {
      do {

        // Se toma en primer par desde el fin, pudiera usarse mejor candidatos.pop(), pero me da error.
        let parEnAnalisis = [String(candidatos[candidatos.length - 1][0]), String(candidatos[candidatos.length - 1][1])];

        console.log(`Analizando ${JSON.stringify(parEnAnalisis)}, de ${candidatos.length} (multiplican ${BigInt(candidatos[candidatos.length - 1][0]) * BigInt(candidatos[candidatos.length - 1][1])}).`);
        candidatos.length = candidatos.length - 1;

        iteraciones++;
        // candidatos = candidatos.filter(elementos => {
        //   return Math.min(elementos[0].length, elementos[1].length) > 1 + Math.round(iteraciones / 800);
        // });
        if (iteraciones = 10000) {
          // probar otro método, luego seguir.

        }

        // Se toma el índice del candidato más corto del par (como cadenas para incluir los ceros)
        let via = parEnAnalisis[0].length < parEnAnalisis[1].length ? 0 : 1;

        // Se convierten las propuestas a enteros grandes, para eliminar ceros a la izquierda
        let propuesta1 = BigInt(parEnAnalisis[via]);
        let propuesta2 = BigInt(parEnAnalisis[1 - via]);

        // Se desecha la propuesta si el tamaño excede la longitud de la raíz cuadrada
        if (propuesta1 > raizCuadrada || propuesta2 > raizCuadrada) {
          continue;
        }

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (propuesta1 !== 1n && valorEnteroGrande % propuesta1 === 0n) {
          return propuesta1.toString();
        } else if (propuesta2 !== 1n && valorEnteroGrande % propuesta2 === 0n) {
          return propuesta2.toString();
        }

        // Se agregan ceros a la izquierda
        // Siempre que los últimos dígitos del producto coincidan
        producto = BigInt(propuesta1 * propuesta2);
        if (producto === valorEnteroGrande) {
          return propuesta1 < propuesta2 ? String(propuesta1) : String(propuesta2);
        } else if (producto < valorEnteroGrande) {
          // agregar todos los candidatos formados por los 10 dígitos a la izquierda incluido el cero
          for (let digito1 = 0; digito1 < 10; digito1++) {
            if (agregarCandidatosDeFactores(String(digito1) + parEnAnalisis[via], parEnAnalisis[1 - via])) {
              // La función hace lo que tiene que hacerSi es resultado es true, es porque casualmente multiplican eso
              return parEnAnalisis[1 - via];
            }
          }
        }
      }
      while (candidatos.length > 0) ;
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  function otroMetodoFactorizacion(x) {
    // Raise the base at the power of exponent
    return 1;
  }

  // Armar una salida elegante (por el momento pasajera), para la factorización del número.
  function factorizacion(x) {
    let resultado;
    let cocienteResidual = BigInt(String(x).trim());
    if (cocienteResidual === 0n || cocienteResidual === 1n) {
      resultado = cocienteResidual.toString();
    } else {
      resultado = '1';
      let menorFactorPrimo;
      do {
        menorFactorPrimo = encontrarMenorFactorPrimo(cocienteResidual);
        if (BigInt(menorFactorPrimo) >= 2n) {
          resultado += ' x ' + menorFactorPrimo.toString();
          cocienteResidual = cocienteResidual / BigInt(menorFactorPrimo);
        }
      } while (BigInt(menorFactorPrimo) >= 2n);
    }
    return resultado;
  }


</script>
<button onclick="imprimirAreaDeTexto(leerAreaDeTexto() + ' = ' + factorizacion(leerAreaDeTexto()));">
    Factorizar
</button>
</body>
</html>