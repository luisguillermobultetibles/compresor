<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<textarea id="textarea1"></textarea>
<p id="salida"></p>
<script>

  document.title = 'Factorización de números grandes (Capítulo I: Ruptura de los retos de RSA en 1 hora).';

  // Factorización "hacker" de números naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el lunes 30 de octubre de 2023; 01:56 PM
  // No critique, sabemos que podemos optimizar y que puede hacerlo mejor, nosotros también
  // no tenemos tiempo para demostrárselo, estamos en fase de pruebas, todavía no llegamos
  // a la fase optimización, depuración y puesta a punto.
  //
  // Todos los derechos reservados, por favor contáctenos personalmente para cualquier uso comercial.
  // Uso académico autorizado.
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  // Try to solve ($200 000.00 premium) RSA-2048
  // textArea1.value = '25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357';

  // By the way, begin with this (should return: 465675465116607065549 x 4892055594575155744537):
  textArea1.value = '2278110264380085376170666039415109857655813';

  function leerAreaDeTexto() {
    return textArea1.value;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.value = String(s);
  }

  // Funciones matemáticas comunes

  // Raiz cuadrada
  // from https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
  function sqrt(value) {
    if (value < 0n) {
      throw 'square root of negative numbers is not supported';
    }

    if (value < 2n) {
      return value;
    }

    function newtonIteration(n, x0) {
      const x1 = ((n / x0) + x0) >> 1n;
      if (x0 === x1 || x0 === (x1 - 1n)) {
        return x0;
      }
      return newtonIteration(n, x1);
    }

    return newtonIteration(value, 1n);
  }

  // power, solo enteros grandes
  function pow(base, exponent) {
    let result;
    if (base === 0n) {
      return 0n;
    } else if (base === 1n) {
      result = 1n;
    } else if (exponent === 2n) {
      result = base * base;
    } else if (exponent === 1n) {
      result = base;
    } else if (exponent === 0n) {
      result = 1n;
    } else if (exponent % 2n === 0n) {
      result = pow(pow(base, exponent / 2n), 2n);
    } else { // Legendre algorithm
      result = base * pow(base, exponent - 1n);
    }
    return result;
  }

  // Raíz enésima
  // from https://stackoverflow.com/questions/64190185/how-do-i-extract-the-nth-root-of-a-bigint-in-javascript
  function root(n, base) {
    // if (n % 2n === 0) return sqrt(root(n / 2, base)); // se degrada la precision en enteros
    let result = base + 1n;
    const k1 = n - 1n;
    let u = base;
    while (u < result) {
      result = u;
      u = ((u * k1) + base / pow(u, k1)) / n;
    }
    return result;
  }

  // Resto de la division base^exp mod m
  function slowModpow(base, exp, m) {
    let result = 1n;
    while (exp > 0n) {
      if (exp % 2n !== 0n) {
        result = (result * base) % m;
      }
      exp = exp / 2n;
      base = (base * base) % m;
    }
    return result;
  }

  function fastModpow(base, exp, m) {
    if (m === 1n) return 0n;
    if (exp === 0n) return 1n % m;
    if (base === 0n) return 0n;
    if ((exp === 1n) && (m !== 0n)) return base % m;
    if (base * exp < 100n) { // fast
      return pow(base, exp) % m;
    } else {
      let there = primes.find((them) => exp % them === 0);
      if (there) {
        exp = exp / there;
        base = pow(base, there);
        return modpow(base, exp, m);
      } else {
        exp = exp - 1n;
        return base * modpow(base, exp, m) % m;
      }
    }
  }

  // Use this global variable as a proxy
  let viaRapida = false;

  function modpow(base, exp, m) {
    if (viaRapida) {
      return fastModpow(base, exp, m);
    } else {
      return slowModpow(base, exp, m);
    }
  }

  function menor(x, y) {
    if (x < y) return x; else return y;
  }

  function mayor(x, y) {
    if (x > y) return x; else return y;
  }

  function mcd(a, b) {
    let result;
    let [minFactor, maxFactor] = [menor(a, b), mayor(a, b)];
    // this trivial checks avoids div. by zero.
    result = maxFactor;
    while (minFactor !== 0n) {
      maxFactor = result;
      result = minFactor;
      minFactor = maxFactor % minFactor;
    }
    return result;
  }

  // x Luis Bultet Ibles. Cuba, logaritmo. (basado en una versión © 2022 PeakU Inc. All Rights Reserved. Colombia)
  function logaritmo(x, base = null) {
    if (x < 0n) return NaN;
    if (!base) { // natural
      return Math.log(16) * (x.toString(16).length - x.toString(16).substring(0, 15).length) + Math.log('0x' + x.substring(0, 15).substring(0, 15));
    }
    switch (base) {
      case 2:
        return logaritmo(x, 10) / Math.log10(2);
      case 10:
        return x.toString(10).length + Math.log10('0.' + x.toString(10).substring(0, 15));
      default:
        return logaritmo(x, 10) / logaritmo(x, base);
    }
  }

  // Elevar el número neperiano e a la potencia de x
  function exponent(x) { // fixit
    let e = '27182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664238';
    e.length = Number(menor(BigInt(e.length), Math.round(logaritmo(x, 10))));
    let result = pow(BigInt(e), x);
    result.length = 1 + Math.trunc(Number(x) / x.length);
    return result;
  }

  // Resolver el problema cuadrático, y devolver las raíces.
  function solveQuadraticProblem(XMasY, XPorY) {
    var result;
    var D1 = pow(XMasY, 2n);
    var D2 = 4n * XPorY;
    var Discriminante = D1 - D2;
    if (Discriminante < 0n) {
      result = []; // NTS en el dominio real
    } else {
      var semiRoot = sqrt(Discriminante) / 2n;
      result = [XMasY - semiRoot, XMasY + semiRoot];
    }
    return result;
  }

  // Resolver una ecuación cuadrática de la forma y = ax² + bx + c, y devolver las raíces.
  function solveQuadraticEquation(a, b, c) {
    let result, root1, root2;
    // calculate discriminant
    let discriminant = b * b - 4n * a * c;
    // condition for real and different roots
    if (discriminant >= 0n) {
      let discRoot = sqrt(discriminant);
      root1 = (-b + discRoot) / (2n * a);
      root2 = (-b - discRoot) / (2n * a);
      result = [root1, root2];
    } else { // if roots are not real
      result = [];
    }
    return result;
  }

  // encuentra [s, t, r] tal que as + bt = d, donde d = mcd(a, b).
  function extendedEuclides(a, b) {
    var q = [];
    var r = [];
    var s = [];
    var t = [];
    var i;
    r[0] = a;
    s[0] = 1n;
    t[0] = 0n;
    r[1] = b;
    s[1] = 0n;
    t[1] = 1n;
    i = 1;
    while (r[i] !== 0n) {
      q[i] = r[i - 1] / r[i];
      r[i + 1] = r[i - 1] % r[i];
      s[i + 1] = s[i - 1] - q[i] * s[i];
      t[i + 1] = t[i - 1] - q[i] * t[i];
      i++;
    }
    return [s[i - 1], t[i - 1], r[i - 1]];
  }

  // resuelve una ecuación diofántica lineal., encontrar [a, b] tal que ax + by = z
  function diofantic(x, y, z) {
    // Primero se chequea si la ecuación diofántica lineal tiene solución : mcd(x, y) / z ?
    let m_c_d = mcd(x, y);
    if (z % m_c_d !== 0n) {
      return []; // NTS (Bezout condition)
    }
    let q = extendedEuclides(x, y);
    let a = q[0] * z / m_c_d;
    let b = q[1] * z / m_c_d;
    return [a, b];
  }

  // primes between 0 and 2.000 - this (0..302 elements) list will be helpful 
  // to perform a primitive primality check.
  let primes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n,
    23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n, 101n,
    103n, 107n, 109n, 113n, 127n, 131n, 137n, 139n, 149n, 151n, 157n, 163n, 167n, 173n, 179n,
    181n, 191n, 193n, 197n, 199n, 211n, 223n, 227n, 229n, 233n, 239n, 241n, 251n, 257n, 263n,
    269n, 271n, 277n, 281n, 283n, 293n, 307n, 311n, 313n, 317n, 331n, 337n, 347n, 349n, 353n,
    359n, 367n, 373n, 379n, 383n, 389n, 397n, 401n, 409n, 419n, 421n, 431n, 433n, 439n, 443n,
    449n, 457n, 461n, 463n, 467n, 479n, 487n, 491n, 499n, 503n, 509n, 521n, 523n, 541n, 547n,
    557n, 563n, 569n, 571n, 577n, 587n, 593n, 599n, 601n, 607n, 613n, 617n, 619n, 631n, 641n,
    643n, 647n, 653n, 659n, 661n, 673n, 677n, 683n, 691n, 701n, 709n, 719n, 727n, 733n, 739n,
    743n, 751n, 757n, 761n, 769n, 773n, 787n, 797n, 809n, 811n, 821n, 823n, 827n, 829n, 839n,
    853n, 857n, 859n, 863n, 877n, 881n, 883n, 887n, 907n, 911n, 919n, 929n, 937n, 941n, 947n,
    953n, 967n, 971n, 977n, 983n, 991n, 997n, 1009n, 1013n, 1019n, 1021n, 1031n, 1033n, 1039n,
    1049n, 1051n, 1061n, 1063n, 1069n, 1087n, 1091n, 1093n, 1097n, 1103n, 1109n, 1117n,
    1123n, 1129n, 1151n, 1153n, 1163n, 1171n, 1181n, 1187n, 1193n, 1201n, 1213n, 1217n,
    1223n, 1229n, 1231n, 1237n, 1249n, 1259n, 1277n, 1279n, 1283n, 1289n, 1291n, 1297n,
    1301n, 1303n, 1307n, 1319n, 1321n, 1327n, 1361n, 1367n, 1373n, 1381n, 1399n, 1409n,
    1423n, 1427n, 1429n, 1433n, 1439n, 1447n, 1451n, 1453n, 1459n, 1471n, 1481n, 1483n,
    1487n, 1489n, 1493n, 1499n, 1511n, 1523n, 1531n, 1543n, 1549n, 1553n, 1559n, 1567n,
    1571n, 1579n, 1583n, 1597n, 1601n, 1607n, 1609n, 1613n, 1619n, 1621n, 1627n, 1637n,
    1657n, 1663n, 1667n, 1669n, 1693n, 1697n, 1699n, 1709n, 1721n, 1723n, 1733n, 1741n,
    1747n, 1753n, 1759n, 1777n, 1783n, 1787n, 1789n, 1801n, 1811n, 1823n, 1831n, 1847n,
    1861n, 1867n, 1871n, 1873n, 1877n, 1879n, 1889n, 1901n, 1907n, 1913n, 1931n, 1933n,
    1949n, 1951n, 1973n, 1979n, 1987n, 1993n, 1997n, 1999n];

  // Known Mersenne number exponents until october 2023
  let knownMersenne = [2n, 3n, 5n, 7n, 13n, 17n, 19n, 31n, 61n, 89n, 107n, 127n, 521n, 607n, 1279n, 2203n,
    2281n, 3217n, 4253n, 4423n, 9689n, 9941n, 11213n, 19937n, 21701n, 23209n, 44497n,
    86243n, 110503n, 132049n, 216091n, 756839n, 859433n, 1257787n, 1398269n, 2976221n,
    3021377n, 6972593n, 13466917n, 20996011n, 24036583n, 25964951n, 30402457n, 32582657n,
    37156667n, 42643801n, 43112609n, 57885161n, 74207281n, 77232917n];

  // El próximo pudiera ser 2^82589933-1

  // La hipótesis china (o hipótesis del chino) plantea que:
  // si p es primo y distinto de dos, entonces (2 ^ p) mod p === 2
  function ChinesseHypothesis(p) {
    let result;
    if (p === 2n) {
      result = {primalidad: true, divisor: 2n};
    } else if (p % 2n === 0n) {
      result = {primalidad: false, divisor: 2n};
    } else {
      result = {primalidad: (p === 2n) || (p % 2n === 0n && p !== 2n) && modpow(2n, p, p) === 2n};
    }
    return result;
  }

  // El pequeño teorema de Fermat, el principe de las matemáticas,
  // plantea que: si p es primo, entonces (a ^ (p-1) ) mod p === 1, si mcd(a, p) === 1
  function FermatLitleTheorem(p, base = 2n) {
    let result;
    let m_c_d = mcd(base, p);
    if (m_c_d !== 1n && m_c_d !== p) {
      result = {primalidad: false, divisor: m_c_d};
    } else {
      result = {primalidad: m_c_d === 1n && modpow(base, p, p) === 1n};
    }
    return result;
  }

  // Pequeño teorema de Fermat, no está completo funciona a veces
  function fermat(p, base = 2n, deep = 100n) {
    let result;
    let prueba = FermatLitleTheorem(p, base);
    if (!prueba.primalidad) {
      return prueba.divisor ? prueba.divisor : p;
    }

    // Ya que p es impar, por diferencia de cuadrados: [2^[(p-1)/2] + 1] * [2^[(p-1)/2] - 1] es divisible por p
    let divisor;
    for (let i = 1n; i < deep; i++) {
      divisor = mcd(p, modpow(2n, p + i, p) - i);
      if (divisor !== 1n && divisor !== p && p % divisor === 0n) return menor(divisor, p / divisor);
      divisor = mcd(p, modpow(2n, p - i, p) - i);
      if (divisor !== 1n && divisor !== p && p % divisor === 0n) return menor(divisor, p / divisor);
    }
    return result;
  }

  // Bultet 2023
  function randomBetween(rightPredecessorLimit, leftLimit = 0n) {
    let result = '0';
    for (let i = 0; i < Math.round(BigInt(rightPredecessorLimit - leftLimit).toString().length); i++) {
      result = result + String(Math.trunc(10 * Math.random()));
    }
    let newLength = Math.round(0.5 + Math.random() * BigInt(rightPredecessorLimit - leftLimit).toString().length);
    result = result.substring(newLength);
    return leftLimit + BigInt(result) % (rightPredecessorLimit - leftLimit);
  }

  // return {primalidad: (x % 2 === 0 && x !== 2n) && modpow(a, x, x) === 2n};
  function rabinMiller(n, k = 16) {
    if (n <= 1n) return {primalidad: false, factor: n};
    if (n <= 3n) return {primalidad: true, factor: n};
    if (n % 2n === 0n) return {primalidad: false, factor: 2n};

    let d = n - 1n;
    let s = 0n;

    while (d % 2n === 1n) {
      d /= 2n;
      s += 1;
    }

    for (let i = 0n; i < k; i++) {
      let a = 2n + randomBetween(n - 4n);
      let x = modpow(a, d, n);

      if (x === 1n || x === n - 1n) {
        continue;
      } else {
        let foundDivisor = false;
        let divisor = 1n;

        for (let j = 0n; j < s - 1n; j++) {
          x = modpow(x, 2n, n);

          if (x === 1n) {
            foundDivisor = true;
            divisor = mcd(x - 1n, n);
            break;
          }

          if (x === n - 1n) {
            break;
          }
        }

        if (foundDivisor) {
          return {primalidad: false, factor: divisor};
        }

        if (x !== n - 1n) {
          return {
            primalidad: false,
            factor: 0n,
            hint: 'Se descarta primalidad por variante II (aunque no se determina el factor).',
          };
        }
      }
    }

    return {primalidad: true, factor: 0n, hint: 'Probablemente sea primo (no se determina el factor).'};
  }

  // Terema de Sofía Germain
  function sofie(x) {
    /*
    Teorema de Sophie Germain:
    “To-do número de la forma x^4 + 4, para x distinto de 1; es compuesto.”
    Demostración (para caso particular y = 1 de la identidad).
      x^4 + 4  = x^4 + 4x^2 + 4 - 4x^2
               = (x^2 + 2) (x^2 + 2) - 4x^2 pues lo anterior es un cuadrado perfecto
               = (x^2 + 2) ^2 - 4x^2
               = (x^2 + 2 + 2x) (x^2 + 2 - 2x) y lo anterior es una diferencia de cuadrados.
      Su generalización es la siguiente identidad:
    “Todos los números de la forma: .x^4 + 4y^4 son compuestos, y se descomponen en (x^2 + 2y^2 + 2xy) (x^2 + 2y^2 - 2xy).”
    Veamos nuestra aplicación del teorema, para la factorización de cualquier número:
    Deseas factorizar P, supones que es compuesto, entonces existen X e Y naturales enteros distintos de 1 tales que P = X Y, luego:
    P = X · Y
    P ^ 4 = (X ^ 4) · (Y ^ 4)
    P ^ 4 = (X ^ 4 + 4 - 4) · (Y ^ 4 + 4 - 4)
    P ^ 4 = [(X^2 + 2 + 2X) (X^2 + 2 – 2X) - 4] · [(Y^2 + 2 + YX) (Y^2 + 2 – 2Y) - 4]
    Que debe ser insoluble para P primo, pues en tal caso alguno de X e Y, debería ser igual a 1 que es, precisamente, la excepción del teorema.
    Por tanto, la cuarta potencia de P debería tomar alguna de las formas,
    P^4 = 1 · P^4 ó P^4 = 1 · P^4, (descartada)
    P^4 = P^2 · P^2, (puede descartarse verificando que P no sea un cuadrado perfecto), luego quedaría la última posibilidad:
    P^4 = P^3 · P^1 ó P^4 = P^1 · P^3, para probar esta, basta con asumir:
    P = [(X^2 + 2 + 2X) (X^2 + 2 – 2X) - 4]
    P ^ 3 = (X^2 + 2X + 2) (X^2 – 2X + 2)
    P ^ 3 debería ser más fácilmente factorizable por alguna otra vía, esta incluso; e igualando sus factores a alguna de las dos ecuaciones, pudiera o no, obtenerse uno de los factores de P (X), lo que demostraría o refutaría su primalidad si fuese posible encontrarlo.
    L.Q.Q.D. (Bye)
        * */
    let factor;
    let divisores = [];

    function xplus4facilmente() {
      return primes.some((one) => {
        if (x + 4n % one === 0n) {
          factor = one;
          return true;
        } else {
          return false;
        }
      });
    }

    // factor = (X^2 + 2 – 2X)

  }

  // (primalidad de números prqueños por fuerza bruta, lenta y exhaustiva)
  function primalidadPorTentativa(x) {
    if (!x || x < 2n) {
      return {primalidad: false, factor: x};
    } else if (x === 2n || x === 3n || x === 5n) {
      return {primalidad: true, factor: x};
    } else if (x % 2n === 0n) {
      return {primalidad: false, factor: 2n};
    } else if (x % 3n === 0n) {
      return {primalidad: false, factor: 3n};
    } else if (x % 5n === 0n) {
      return {primalidad: false, factor: 5n};
    } // Pueden agregarse los criterios de divisibilidad...
    // Ningún número tiene divisores primos por encima de su raiz cuadrada
    let up = sqrt(x);

    let valorInicial = 7n;

    let multiploDeTres = (valorInicial + 2n) % 3n === 0n;

    function flipFlop() {
      multiploDeTres = !multiploDeTres; // es más rápido que probar una divisibilidad
      return multiploDeTres ? 4n : 2n;
    }

    for (var testNo = valorInicial; testNo <= up; testNo += flipFlop()) {
      if (x % testNo === 0n) {
        return {primalidad: false, factor: testNo};
      }
    }
    return {primalidad: true, factor: x};
  }

  // Implementación del algoritmo de Pollard Rho para factorización de números enteros
  function pollardRho(n, verbose = false) {
    if (n % 2n === 0n) {
      return {primalidad: n === 2n, factor: 2n};
    }

    let a = 2n;
    let b = 2n;
    let divisor = 1n;

    // Bultet cycle detection
    let cycle = false;
    let a0;
    let b0;

    while (divisor === 1n) {
      a = (a * a + 1n) % n;
      b = (b * b + 1n) % n;
      b = (b * b + 1n) % n;

      if (b > a) {
        divisor = mcd(n + a - b, n); // to avoid negative result's
      } else {
        divisor = mcd(a - b, n);
      }

      // cycle detection
      if (!cycle) {
        a0 = a;
        b0 = b;
        cycle = true;
      } else if (a === a0 && b === b0) {
        break;
      }

      if (verbose) console.warn(`d = ${divisor}, x = ${a}, y = ${b}`);
    }

    return {primalidad: divisor === 1n, factor: divisor === 1n ? n : divisor};
  }

  // Mala implementación del algoritmo de la curva elíptica de Lenstra (ECM) by ShitGPT
  function lenstraECM(n) {

    function ecmFactor(n) {
      // Función auxiliar para calcular el máximo común divisor (GCD) entre dos números
      function gcd(a, b) {
        if (b == 0) {
          return a;
        }
        return gcd(b, a % b);
      }

      // Función auxiliar para calcular el inverso multiplicativo de un número módulo n
      function modInverse(a, n) {
        let t = 0,
          newt = 1,
          r = n,
          newr = a;

        while (newr !== 0) {
          let quotient = Math.floor(r / newr);
          [t, newt] = [newt, t - quotient * newt];
          [r, newr] = [newr, r - quotient * newr];
        }

        if (t < 0) {
          t = t + n;
        }

        return t;
      }

      // Verificar si n es un número primo
      function isPrime(n) {
        if (n <= 1) {
          return false;
        }
        if (n <= 3) {
          return true;
        }
        if (n % 2 === 0 || n % 3 === 0) {
          return false;
        }

        let i = 5;
        while (i * i <= n) {
          if (n % i === 0 || n % (i + 2) === 0) {
            return false;
          }
          i += 6;
        }

        return true;
      }

      // Calcular el punto P = a * P en la curva elíptica definida por y^2 ≡ x^3 + ax + b (mod n)
      function multiplyPoint(a, b, n, P) {
        if (P === null) {
          return null;
        }

        const [x, y] = P;
        let slope, newX, newY;

        if (y === 0) {
          return null;
        }

        slope = ((3 * x * x + a) * modInverse(2 * y, n)) % n;
        newX = (slope * slope - 2 * x) % n;
        newY = (slope * (x - newX) - y) % n;

        return [newX, newY];
      }

      // Generar un punto inicial aleatorio en la curva elíptica definida por y^2 ≡^3 + ax + b (mod n)
      function generateRandomPoint(a, b, n) {
        const x = Math.floor(Math.random() * n);
        const y2 = (x * x * x + a * x + b) % n;
        const y = Math.sqrt(y2);
        return [x, y];
      }

      if (isPrime(n)) {
        return n; // Si n es primo, no se puede factorizar
      }

      // Intentar encontrar un factor utilizando el algoritmo de Lenstra (ECM)
      let a = 1,
        b = 1,
        P = generateRandomPoint(a, b, n);

      while (P !== null) {
        if (gcd(2 * P[1], n) !== 1) {
          return gcd(2 * P[1], n); // Encontró un factor
        }
        a++;
        b = (P[0] * P[0] - n) / (a * a); // Calcular b = (x^2 - n) / a^2
        P = multiplyPoint(a, b, n, P); // Calcular el siguiente punto
      }

      return null; // No se pudo encontrar un factor
    }

    // Llamar al algoritmo de la curva elíptica de Lenstra (ECM)
    return lenstraECM(n);
  }


  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarUnFactorPrimo(decimal) {
    decimal = String(decimal).trim();

    // hasta 18 dígitos...
    let valorEnteroGrande = BigInt(decimal);
    // if (decimal.length < 18) {
    //   return primalidadPorTentativa(valorEnteroGrande).factor;
    // }

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (valorEnteroGrande < 4n) {
      return resultado;
    }

    // Pruebas extras

    // Es divisible por uno de los primeros 300 números primos
    let there = primes.find((them) => valorEnteroGrande % them === 0n);
    if (there) {
      return there.toString();
    }

    // Es un cuadrado perfecto? (solamente pueden serlo los de la forma 4s o 4s + 1.)
    function isAPerfectSquare(s) {
      let mod4 = s % 4n;
      if (mod4 !== 0n || mod4 !== 1n) {
        return false;
      }
      return s === pow(sqrt(s), 2n);
    }

    // this return [(base^exp) - d] mod m
    // I deduced it by applying the Chinese remainder theorem
    function modpowplus(base, exp, d, m) {
      return (m + d + modpow(base, exp, m)) % m; // m added to induce positive results.
    }

    // Es múltiplo o alguno de los primos de Mersenne conocidos hasta 2023 (Just fix this section, to improve performance).
    // if (valorEnteroGrande % 2n === 0n) return 2n;
    /*     let log2 = Math.trunc(Number(logaritmo(valorEnteroGrande, 2)));
        for (const exponent of knownMersenne) {
          let rest = modpow(2n, exponent, valorEnteroGrande);
          rest--;
          if (rest === 0n) {
            alert('ok');
            return pow(2n, exponent) - 1n;
          } else {
            if (rest > 1n) {
              rest = mcd(valorEnteroGrande, rest);
              if (rest > 1n && rest !== valorEnteroGrande && valorEnteroGrande % rest === 0n) {
                alert('ok');
                return rest;
              }
            }
          }
        } */

    let raizCuadrada = sqrt(valorEnteroGrande);
    if (raizCuadrada >= 2n && valorEnteroGrande % raizCuadrada === 0n) {
      return encontrarUnFactorPrimo(raizCuadrada);
    }

    let factorFermat = fermat(valorEnteroGrande);
    if (factorFermat >= 2n && factorFermat !== valorEnteroGrande && valorEnteroGrande % factorFermat === 0n) {
      return menor(factorFermat, valorEnteroGrande / factorFermat);
    }

    // elimina esto para activar el código de abajo, utilízalo en un mejor lugar.
    return pollardRho(valorEnteroGrande);

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => {
          return element[0] === par[0] && element[1] === par[1];
        },
      );
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos

    function agregarCandidatosDeFactores(factor1, factor2) {
      let notDivisorFoundResult = 0n;
      // si no existe el par en la lista agrégalo (si no exceden la raíz cuadrada)
      [factor1, factor2] = [menor(factor1, factor2), mayor(factor1, factor2)];
      let subProd = BigInt(factor1) * BigInt(factor2);

      if (existsCandidates([factor1, factor2]) || subProd > valorEnteroGrande || (factor1.length + factor2.length > decimal.length) || BigInt(factor1) > raizCuadrada || BigInt(factor2) > raizCuadrada) {
        return notDivisorFoundResult;
      }

      if (BigInt(factor1) !== 1n && BigInt(factor2) !== 1n && BigInt(factor1) !== valorEnteroGrande && BigInt(factor2) !== valorEnteroGrande) {
        if (valorEnteroGrande % BigInt(factor1) === 0n) {
          return factor1;
        } else if (valorEnteroGrande % BigInt(factor2) === 0n) {
          return factor2;
        }
      }

      if (coincidenciasAlFinal(decimal, subProd.toString()) >= subProd.toString().length - 3) {
        candidatos.push([factor1, factor2]);
      }

      return notDivisorFoundResult;
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(1, decimal);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores('1', '1');
        agregarCandidatosDeFactores('3', '7');
        agregarCandidatosDeFactores('9', '9');
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores('1', '3');
        agregarCandidatosDeFactores('7', '9');
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores('1', '7');
        agregarCandidatosDeFactores('3', '9');
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores('1', '9');
        agregarCandidatosDeFactores('3', '3');
        agregarCandidatosDeFactores('7', '7');
        break;
      }
    }

    function menorFactor(b) {
      let a = valorEnteroGrande / BigInt(b);

      // Es recursiva, primero sácale presión a la caldera
      candidatos = [];

      x = encontrarUnFactorPrimo(a);
      y = encontrarUnFactorPrimo(b);

      return menor(x, y);
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    raizCuadrada = sqrt(valorEnteroGrande);

    if (candidatos.length > 0) {
      do {

        let parEnAnalisis = [0, 0];

        // Se toma un par desde el final
        parEnAnalisis = [candidatos[candidatos.length - 1][0], candidatos[candidatos.length - 1][1]];
        candidatos.length = candidatos.length - 1;

        // Se toma el índice del candidato más corto del par (como cadenas para incluir los ceros)
        let via = parEnAnalisis[0].length < parEnAnalisis[1].length ? 0 : 1;

        // Se convierten las propuestas a enteros grandes, para eliminar ceros a la izquierda
        let propuesta1 = BigInt(parEnAnalisis[via]);
        let propuesta2 = BigInt(parEnAnalisis[1 - via]);

        //
        // console.log(`Analizando ${[propuesta1, propuesta2]}, de ${candidatos.length} (multiplican ${BigInt(propuesta1) * BigInt(propuesta2)}).`);

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (propuesta1 !== 1n && propuesta1 !== valorEnteroGrande && valorEnteroGrande % propuesta1 === 0n) {
          return propuesta1.toString();
        } else if (propuesta2 !== 1n && propuesta2 !== valorEnteroGrande && valorEnteroGrande % propuesta2 === 0n) {
          return propuesta2.toString();
        }

        // Se agregan ceros a la izquierda
        // Siempre que los últimos dígitos del producto coincidan

        for (let digito1 = 0; digito1 < 10; digito1++) {
          for (let digito2 = 0; digito2 < 10; digito2++) {
            let div = agregarCandidatosDeFactores(String(digito1) + parEnAnalisis[via], String(digito2) + parEnAnalisis[1 - via]);
            if (div !== 0n) {
              return div;
            }
          }
        }


      } while (candidatos.length > 0) ;
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  function encontrarElMenorFactorPrimo(decimal) {
    let primero = BigInt(encontrarUnFactorPrimo(decimal)); // inclusive un divisor cualquiera, no necesariamente primo
    if (primero > 1n && primero !== BigInt(decimal)) {
      let segundo = BigInt(encontrarUnFactorPrimo((BigInt(decimal) / primero).toString()));
      return menor(primero, segundo);
    } else {
      return BigInt(primero);
    }
  }


  function otroMetodoFactorizacion(x) {
    // Raise the base at the power of exponent
    return 1;
  }

  // Una solución elegante de Mauricio Contreras, https://es.stackoverflow.com/users/112837/mauricio-contreras
  // en https://es.stackoverflow.com/questions/236576/descomponer-n%C3%BAmero-entero-en-factores-primos-con-javascript
  // que porteamos a BigInt y a la que llamamos:
  function teoremaGeneralDeLaAritmetica(n, sintaxisExtendida = false) {
    let resultado = []; // aqui almacenaremos los factores de forma más legible
    if (n === 0n || n === 1n) {
      resultado = sintaxisExtendida && n === 1n ? [{factor: 2n, exponente: 0n}] : [{factor: n, exponente: 1n}];
    } else {
      let arr = []; //aqui almacenamos los factores temporalmente
      let division = n;// el primer valor que usaremos es N
      while (division > 1n) { // 'resultado' irá variando hasta hacerse 1
        let divisor = encontrarUnFactorPrimo(division);
        try {
          division = BigInt(division) / BigInt(divisor); //actualizamos el valor de resultadodivision = BigInt(division) / BigInt(divisor); //actualizamos el valor de resultado
        } catch (e) {
          alert(`Error: ${JSON.stringify(e)} division === ${division} y divisor === ${divisor}.`);
        }
        arr.push(divisor);
      }
      let factor = arr[0]; // almacenamos el primer valor
      let cont = 1n; // instanciamos la cantidad de veces que aparece el primer elemento
      if (arr.length > 1) { // si hay más de 1 elemento en el array
        for (let i = 1; i < arr.length; i++) {
          if (factor !== arr[i]) { // si el factor cambia, ya no se repite más, podemos almacenarlo
            resultado.push({factor: factor, exponente: cont});
            factor = arr[i]; // establecemos el nuevo factor
            cont = 0n; // inciamos el contador en cero, en la siguiente línea aumentará 1
          }
          cont++; // si el factor se repite, aumentamos el contador, si estaba en cero se aumenta a 1
        }
        resultado.push({factor: factor, exponente: cont}); // almacenamos el último factor encontrado
      } else { // en caso de que N sea primo, solo tiene un factor
        resultado.push({factor: factor, exponente: cont});
      }
      if (!sintaxisExtendida) {
        resultado = [{factor: 1n, exponente: 1n}].concat(resultado); // El 1 los divide a todos
      }
    }
    return resultado;
  }

  // Presentar una factorización del número, en formato humano. (arreglar)
  function factorizacion(s, compresion = false, espaciado = ' ') {

    function formatearPrimerFactor(a) {
      let divisor;
      let exponente = '1';
      let result;
      let residuo;
      if (a === '1') {
        divisor = '2';
        exponente = '0';
      } else if (a === '0') {
        divisor = '0';
        exponente = '1';
      } else {
        exponente = '0';
        divisor = encontrarUnFactorPrimo(a);
        if (a === divisor) {
          divisor = a;
          exponente = '1';
        } else {
          [a, residuo] = [(BigInt(a) / BigInt(divisor)).toString(), (BigInt(a) % BigInt(divisor)).toString()];
          while (residuo === '0' && a !== '1') {
            [a, residuo] = [(BigInt(a) / BigInt(divisor)).toString(), (BigInt(a) % BigInt(divisor)).toString()];
            exponente = (BigInt(exponente) + 1n).toString();
          }
        }
      }
      return [divisor, exponente];
    }

    let result;
    let divisorPrimo, exponente;
    let dummyrest;
    let temporal;

    result = s;
    if (BigInt(s) < 3n) return result;

    result = '1';
    do {
      do {
        [divisorPrimo, exponente] = formatearPrimerFactor(s);
        if (exponente !== '1') {
          if (exponente !== '2') {
            result = result + espaciado + 'x' + espaciado + divisorPrimo + '²';
          } else if (exponente === '3') {
            result = result + espaciado + 'x' + espaciado + divisorPrimo + '³';
          } else if (compresion) {
            function modoRecursivo(s) {
              if (divisorPrimo === s) {
                return s;
              } else {
                return '(' + factorizacion(s, compresion, espaciado) + ')';
              }
            }

            result = result + espaciado + 'x' + espaciado + ('(' + modoRecursivo(divisorPrimo) + espaciado + '^' + espaciado + modoRecursivo(exponente) + ')');
          } else {
            result = result + espaciado + 'x' + espaciado + ('(' + divisorPrimo + espaciado + '^' + espaciado + exponente + ')');
          }
        } else {
          result = result + espaciado + 'x' + espaciado + divisorPrimo;
        }
        [s, dummyRest] = [(BigInt(s) / (BigInt(divisorPrimo) ** BigInt(exponente))).toString(), (BigInt(s) % (BigInt(divisorPrimo) ** BigInt(exponente))).toString()];
      } while ((s !== '1') && (s !== '1') && (dummyRest === '0'));
      // pon esto
      // s := Dividir(s, Potencia(pdi, pws), dummyRest);
    } while (s !== '0' && s !== '1');
    return result;
  }

  function test() {
    function repetir(digito, veces) {
      result = '';
      for (let i = 0; i < veces; i++) {
        result = result + digito;
      }
      return result;
    }

    alert('Enter para comenzar el test de depuración.');
    for (let i = 0n; i < 1111111n; i++) {
      let no = BigInt(repetir('1', i));
      // console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${encontrarUnFactorPrimo(no)}<--.`);
      // console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${encontrarUnFactorPrimo(no)}<--.`);
      // console.warn(`Un factor primo de 2^${no} - 1 = ${pow(2n, no) - 1n}, es -->${encontrarUnFactorPrimo(pow(2n, no) - 1n)}<--.`);
      // console.warn(`Un factor primo de ${no} (con ${i} dígitos 1), es -->${primalidadPorTentativa(no).factor}<-- (brute force).`);
      console.warn(`Un factor primo de ${i}, es -->${primalidadPorTentativa(i).factor}<-- (brute force).`);
    }
  }

  ////////////////

  // Fix this...
  function humanExposition(entero, compression = false) {
    let resultado = '';
    // llamamos a la función que calcula los factores primos
    let factoresPrimos = teoremaGeneralDeLaAritmetica(entero);
    // construimos el string del resultado
    for (let i = 0; i < factoresPrimos.length; i++) {
      if (html) { // si usamos el 'tag' <sup> de HTML
        resultado += (factoresPrimos[i].factor).toString();
        +'<sup>'
        + compression && factoresPrimos.length > 1 ? humanExposition((BigInt(factoresPrimos[i].exponente)), html, compression) : (factoresPrimos[i].exponente).toString()
          + '</sup>' + (i < factoresPrimos.length - 1 ? ' x ' : '');
      } else {
        resultado += (factoresPrimos[i].factor).toString()
        + compression && factoresPrimos.length > 1 ? humanExposition((BigInt(factoresPrimos[i].exponente)), html, compression) : (factoresPrimos[i].exponente).toString()
          + (i < factoresPrimos.length - 1 ? ' x ' : '');
      }
    }
    return resultado;
  }

  function calcular(entero) {
    //instanciamos el elemento de salida
    let salida = document.getElementById('salida');
    // llamamos a la función que calcula los factores primos
    let factoresPrimos = teoremaGeneralDeLaAritmetica(entero);
    // construimos el string del resultado
    let resultado = entero.toString() + ' = ';
    for (let i = 0; i < factoresPrimos.length; i++) {
      //usaremos el 'tag' <sup> de HTML
      resultado += (factoresPrimos[i].factor).toString() + '<sup>' + (factoresPrimos[i].exponente).toString() + '</sup>' + (i < factoresPrimos.length - 1 ? ' x ' : ' x 1');
    }
    // escribimos la salida
    salida.innerHTML = resultado;
  }

  ///////////////////////


  // remove this line when fix encontrarMenorFactorPrimo and factorización
  // test();

</script>
<button onclick="calcular(BigInt(leerAreaDeTexto()));">
    Factorizar
</button>
</body>
</html>