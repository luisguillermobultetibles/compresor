<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<textarea id="textarea1">123456789</textarea>
<script>

  // Factorización "hacker" de númeroe naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el Domingo 22 de octubre de 2023; 11:20 AM
  // (pendiente de depuración y corrección de errores sintácticos, "por favor la vida, que no vale sin decoro")
  // Todos los derechos reservados, por favor contácmeme personalmente para cualquier uso comercial.
  // Uso educativo autorizado.  
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  function leerAreaDeTexto() {
    return textArea1.textContent;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.textContent = String(s);
  }

  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarMenorFactorPrimo(decimal) {
    decimal = String(decimal);
    let longVersion = BigInt(decimal);

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos de las dos cadenas coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          let par = [nUtimosDigitosDeX(i, X), nUtimosDigitosDeX(i, Y)];
          resultado = par[0] === par[1] ? i : resultado;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (longVersion < 1n) {
      return resultado; // devolver la entrada, pasa menor que dos y hasta tres, pero déjalo así para legibilidad
    }

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => element[0] === par[0] && element[1] === par[1]);
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos
    function agregarCandidatosDeFactores(factor1, factor2) {
      // en orden
      let par = BigInt(factor1) < BigInt(factor2) ? [factor1, factor2] : [factor2, factor1];
      // si no existe el par en la lísta agrégalo
      if (!existsCandidates(par)) {
        candidatos.push();
      }
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(decimal, 1);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores(1n, 1n);
        agregarCandidatosDeFactores(3n, 7n);
        agregarCandidatosDeFactores(9n, 9n);
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores(1n, 3n);
        agregarCandidatosDeFactores(7n, 9n);
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores(1n, 7n);
        agregarCandidatosDeFactores(3n, 9n);
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores(1n, 9n);
        agregarCandidatosDeFactores(3n, 3n);
        break;
      }
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    // Se toma la mitad del número decimal mas 1 como el límite de búsqueda,
    // Se asume cercano por la izquierda a la raíz.
    let mitadLongitud = Math.trunc(decimal.length / 2) + 1;
    mitadLongitud = mitadLongitud > decimal.length ? decimal.length : mitadLongitud;

    if (candidatos.length > 0) {
      do {

        // Se toma en primer par
        let parEnAnalisis = [Stcandidatos[0][0], candidatos[0][1]];

        // Se elimina de la lista
        candidatos = candidatos.shift();

        // Si los candidatos exceden el tamaño estimado para la raiz, simplemente se elimina la rama
        if (parEnAnalisis[0].length > mitadLongitud && parEnAnalisis[1].length > mitadLongitud) {
          continue;
        }

        // Se toma el índice del menor candidato del par
        let via = BigInt(parEnAnalisis[0]) < BigInt(parEnAnalisis[1]) ? 0 : 1;

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (parEnAnalisis[via][0] !== '0' && BigInt(parEnAnalisis[via]) !== 1n && longVersion % BigInt(parEnAnalisis[via]) === 0n) {
          return BigInt(parEnAnalisis[via]).toString();
        } else if (parEnAnalisis[1 - via][0] !== '0' && BigInt(parEnAnalisis[1 - via]) !== 1n && longVersion % BigInt(parEnAnalisis[1 - via]) === 0n) {
          return BigInt(parEnAnalisis[1 - via]).toString();
        }

        // agregar todos los candidatos formados por los 10 dígitos a la izquierda incluido el cero
        for (let digito = 0; digito < 10; digito++) {
          // Se agregan ceros a la izquierda
          let propuesta1 = parEnAnalisis[via];
          let propuesta2 = parEnAnalisis[1 - via];
          // Siempre que los últimos dígitos del producto coincidan
          let producto = BigInt(BigInt(propuesta1) * BigInt(propuesta2)).toString();
          if (coincidenciasAlFinal(decimal, producto) <= (producto.length - 2)) {
            // Con al menos dos dígitos de error para el acarreo
            agregarCandidatosDeFactores(String(digito) + parEnAnalisis[via], parEnAnalisis[1 - via]);
          }
        }
      } while (candidatos.length > 0);
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  // Armar una salida elegante (por el momento pasajera), para la factorización del número.
  // Armar una salida elegante (por el momento pasajera), para la factorización del número.
  function factorizacion(x) {
    let resultado;
    let cocienteResidual = BigInt(x);
    if (cocienteResidual === 0n || cocienteResidual === 1n) {
      resultado = cocienteResidual.toString();
    } else {
      resultado = '1';
      let menorFactorPrimo = 2n; // to enter
      do {
        menorFactorPrimo = encontrarMenorFactorPrimo(cocienteResidual);
        if (menorFactorPrimo >= 2n) {
          resultado += ' * ' + menorFactorPrimo.toString();
          cocienteResidual /= BigInt(menorFactorPrimo);
        }
      } while (menorFactorPrimo >= 2n);
    }
    return resultado;
  }


</script>
<button onclick="imprimirAreaDeTexto(factorizacion(leerAreaDeTexto()));">Factorizar</button>
</body>
</html>
