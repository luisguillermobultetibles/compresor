<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Factorización de números naturales muy grandes.</title>
</head>
<body>
<textarea id="textarea1"></textarea>
<script language="JavaScript">

  // Factorización "hacker" de números naturales grandes por algoritmo de Branch and Exchange.
  // Copyright ®Luis Guillermo Bultet Ibles, el lunes 23 de octubre de 2023; 11:20 AM
  // En fase de depuración y puesta a punto.
  //
  // Todos los derechos reservados, por favor contáctenos personalmente para cualquier uso comercial.
  // Uso académico autorizado.
  // Cuba.

  // Entrada y salida

  let textArea1 = document.getElementById('textarea1');

  // Try to solve ($200 000.00 premium) RSA-2048
  // textArea1.value = '25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357';

  // By the way, begin with this (should return: 465675465116607065549 x 4892055594575155744537):
  textArea1.value = '2278110264380085376170666039415109857655813';

  function leerAreaDeTexto() {
    return textArea1.value;
  }

  function imprimirAreaDeTexto(s) {
    textArea1.value = String(s);
  }

  // Lógica para factorización de un número tan grande como se quiera o aguante la memoria.

  function encontrarMenorFactorPrimo(decimal) {
    decimal = String(decimal);
    let valorEnteroGrande = BigInt(decimal);

    // Extraer los n últimos dígitos de X
    function nUtimosDigitosDeX(n, X) {
      return String(X).substring(String(X).length - n);
    }

    // Cuántos de los últimos dígitos coinciden
    function coincidenciasAlFinal(X, Y) {
      let resultado = 0;
      for (let i = 1; i < Math.min(X.length, Y.length); i++) {
        if (X[X.length - i] === Y[Y.length - i]) {
          resultado++;
        } else {
          break;
        }
      }
      return resultado;
    }

    let resultado = decimal;

    let candidatos = [];

    if (valorEnteroGrande < 4n) {
      return resultado;
    }

    // Raiz cuadrada
    // from https://stackoverflow.com/questions/53683995/javascript-big-integer-square-root
    function sqrt(value) {
      if (value < 0n) {
        throw 'square root of negative numbers is not supported';
      }

      if (value < 2n) {
        return value;
      }

      function newtonIteration(n, x0) {
        const x1 = ((n / x0) + x0) >> 1n;
        if (x0 === x1 || x0 === (x1 - 1n)) {
          return x0;
        }
        return newtonIteration(n, x1);
      }

      return newtonIteration(value, 1n);
    }

    let raizCuadrada = sqrt(valorEnteroGrande);
    if (raizCuadrada >= 2 && valorEnteroGrande % raizCuadrada === 0n) {
      return encontrarMenorFactorPrimo(raizCuadrada);
    }

    function existsCandidates(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      return candidatos.some((element) => {
          return element[0] === par[0] && element[1] === par[1];
        },
      );
    }

    // Agregar dos posibles terminaciones para los factores a la lista de candidatos
    function agregarCandidatosDeFactores(factor1, factor2) {
      // en orden
      let par = factor1 < factor2 ? [factor1, factor2] : [factor2, factor1];
      // si no existe el par en la lista agrégalo (si no exceden la raíz cuadrada)
      if (!existsCandidates(par) &&
        factor1.length <= raizCuadrada.toString().length &&
        factor1.length <= raizCuadrada.toString().length &&
        BigInt(factor1) ** 2n < raizCuadrada &&
        BigInt(factor2) ** 2n < raizCuadrada) {
        // además
        if (coincidenciasAlFinal(decimal, (BigInt(factor1)*BigInt(factor2)).toString()) >= (factor1.length + factor2.length - 3)) {
          // Con al menos dos o tres (4?) dígitos de error para el acarreo y se concatenan con su formato actual
          candidatos.push([factor1, factor2]);
        }
      }
    }

    // De acuerdo a la terminación del número primo a factorizar solo tenemos algunas posibilidades
    let ultimoDigito = nUtimosDigitosDeX(1, decimal);

    switch (ultimoDigito) {
      case '0': {
        return '2';
        break;
      }
      case '1': {
        // Una terminación 1, solamente es posible por el producto de las terminaciones 1 x 1, 3 x 7 y 9 x 9
        agregarCandidatosDeFactores('1', '1');
        agregarCandidatosDeFactores('3', '7');
        agregarCandidatosDeFactores('9', '9');
        break;
      }
      case '2': {
        return '2';
        break;
      }
      case '3': {
        // Una terminación 3, solamente es posible por el producto de las terminaciones 1 x 3 y 7 x 9
        agregarCandidatosDeFactores('1', '3');
        agregarCandidatosDeFactores('7', '9');
        break;
      }
      case '4': {
        return '2';
        break;
      }
      case '5': {
        return '5';
        break;
      }
      case '6': {
        return '2';
        break;
      }
      case '7': {
        // Una terminación 7, solamente es posible por el producto de las terminaciones 1 x 7 y 3 x 9
        agregarCandidatosDeFactores('1', '7');
        agregarCandidatosDeFactores('3', '9');
        break;
      }
      case '8': {
        return '2';
        break;
      }
      case '9': {
        // Una terminación 9, solamente es posible por el producto de las terminaciones 1 x 9 y 3 x 3
        agregarCandidatosDeFactores('1', '9');
        agregarCandidatosDeFactores('3', '3');
        agregarCandidatosDeFactores('7', '7');
        break;
      }
    }

    // Agregamos una semilla a la derecha por fuerza bruta, a lo sumo 100 casos
    // y la hacemos crecer mientras los últimos dígitos del factor coincidan dentro
    // del margen de acarreo, hasta que se encuentre uno que divida o se exceda el
    // límite de la búsqueda del primer factor primo.

    // Después de 200 iteraciones se eliminan los candidatos de menos dos dígitos,
    // de 300 las de menos de tres, así sucesivamente;
    let iteraciones = 0;

    if (candidatos.length > 0) {
      do {

        // Se toma en primer par
        let parEnAnalisis = [String(candidatos[0][0]), String(candidatos[0][1])];
        console.log(`Analizando ${JSON.stringify(parEnAnalisis)}, de ${candidatos.length}.`);
        candidatos.shift();

        // iteraciones++;
        // candidatos = candidatos.filter(elementos => {
        //   return elementos[0].length > Math.trunc(iteraciones / 100) && elementos[1].length > Math.trunc(iteraciones / 100);
        // });

        // Se toma el índice del candidato más corto del par (como cadenas para incluir los ceros)
        let via = parEnAnalisis[0].length < parEnAnalisis[1].length ? 0 : 1;

        // Se convierten las propuestas a enteros grandes, para eliminar ceros a la izquierda
        let propuesta1 = BigInt(parEnAnalisis[via]);
        let propuesta2 = BigInt(parEnAnalisis[1 - via]);

        // Se desecha la propuesta si el tamaño excede la longitud de la raíz cuadrada
        if (propuesta1 > raizCuadrada || propuesta2 > raizCuadrada) {
          continue;
        }

        // Se prueba si es una semilla ha crecido correctamente y ya es un divisor
        // Si se agregó un cero a la izquierda, no se vuele a chequear.
        if (propuesta1 !== 1n && valorEnteroGrande % propuesta1 === 0n) {
          return propuesta1.toString();
        } else if (propuesta2 !== 1n && valorEnteroGrande % propuesta2 === 0n) {
          return propuesta2.toString();
        }

        // agregar todos los candidatos formados por los 10 dígitos a la izquierda incluido el cero
        for (let digito = 0; digito < 10; digito++) {
          // Se agregan ceros a la izquierda
          // Siempre que los últimos dígitos del producto coincidan
          let producto = BigInt(propuesta1 * propuesta2);
          if (producto === valorEnteroGrande) {
            return propuesta1 < propuesta2 ? String(propuesta1) : String(propuesta2);
          } else {
            agregarCandidatosDeFactores(String(digito) + parEnAnalisis[via], parEnAnalisis[1 - via]);
            agregarCandidatosDeFactores(parEnAnalisis[via], String(digito) + parEnAnalisis[1 - via]);
          }
        }
      } while (candidatos.length > 0);
    }

    // devolver la entrada, no se encontraron factores.
    return resultado;
  }

  // Armar una salida elegante (por el momento pasajera), para la factorización del número.
  function factorizacion(x) {
    let resultado;
    let cocienteResidual = BigInt(String(x).trim());
    if (cocienteResidual === 0n || cocienteResidual === 1n) {
      resultado = cocienteResidual.toString();
    } else {
      resultado = '1';
      let menorFactorPrimo;
      do {
        menorFactorPrimo = encontrarMenorFactorPrimo(cocienteResidual);
        if (BigInt(menorFactorPrimo) >= 2n) {
          resultado += ' x ' + menorFactorPrimo.toString();
          cocienteResidual = cocienteResidual / BigInt(menorFactorPrimo);
        }
      } while (BigInt(menorFactorPrimo) >= 2n);
    }
    return resultado;
  }

</script>
<button onclick="imprimirAreaDeTexto(leerAreaDeTexto() + ' = ' + factorizacion(leerAreaDeTexto()));">
    Factorizar
</button>
</body>
</html>